# Effective C++

- [Part-1.让自己习惯C++](#Part-1.让自己习惯C++)
	- [条款01.视C++为一个语言联邦](#条款1.视C++为一个语言联邦)
	- [条款02.尽量以const，enum，inline替换 #define](#条款2.尽量以const，enum，inline替换#define)
	- [条款03.尽可能使用const](#条款3.尽可能使用const)
	- [条款04.确认对象被使用前已经被初始化](#条款4.确认对象被使用前已经被初始化)
- [Part-2.构造/析构/赋值运算](#Part-2.构造/析构/赋值运算)
	- [条款05：了解C++默默编写并调用了哪些函数](#条款5：了解C++默默编写并调用了哪些函数)
	- [条款06：若不想使用编译器自动生成的函数，就该明确拒绝。](#条款06：若不想使用编译器自动生成的函数，就该明确拒绝。)
	- [条款07：为多态基类声明virtual](#条款07：为多态基类声明virtual)
	- [条款08：别让异常逃离析构函数](#条款08：别让异常逃离析构函数)
	- [条款09：绝不在构造和析构过程中调用virtual函数。](#条款09：绝不在构造和析构过程中调用virtual函数。)
	- [条款10：令operator=返回一个reference-to-*this](#条款10：令operator=返回一个reference-to-*this)
	- [条款11：在operator=中处理“自我赋值”](#条款11：在operator=中处理“自我赋值”)
    - [条款12：复制对象时勿忘其每一个成分](#条款12：复制对象时勿忘其每一个成分)
- [Part-3.资源管理](#Part-3.资源管理)
    - [条款13：以对象管理资源](#条款13：以对象管理资源)
    - [条款14：在资源管理类小心copy行为](#条款14：在资源管理类小心copy行为)
    - [条款15：在资源管理类中提供对原始资源的访问](#script-parameters)
    - [条款16：成对使用new和delete要采用相同的格式](#script-parameters)
    - [条款17：以独立的语句将newd对象置入智能指针](#script-parameters)
- [Part-4.设计与声明](#Part-4.设计与声明)
    - [条款13：以对象管理资源](#条款13：以对象管理资源)
    - [条款14：](#script-parameters)
    - [条款14：](#script-parameters)
    - [条款14：](#script-parameters)
    - [条款14：](#script-parameters)

# [Part-1.让自己习惯C++](#contents)

![Pix2Pix Imgs](imgs/Pix2Pix-examples.jpg)

## [条款01.视C++为一个语言联邦](#contents)

c++是多重范型编程语言，视c++包括4种次语言： 

1：C； 

2：Object-Oreinted C++；

3：Template C++；

4：STL（template程序库，包括容器、迭代器、算法和函数对象）

## [条款02.尽量以const，enum，inline替换 #define](#contents)

**const**

1.#define直接替换导致名称未被编译器看到

2.#define不重视作用域，所以无法提供封装性

**enum**

1.取一个const的地址是合法的，但是取enum的地址不合法

**inline**

1.#define定义函数可能导致误用，最好用inline函数替换

**注意**

对于单纯常量，最好以const对象或enums替换#defines；

对于形似函数的宏，最好改用inline函数替换#defines。

## [条款03.尽可能使用const](#contents)

1.令函数返回一个常量值，可以预防无意义的赋值动作（例：p19）

**const成员函数**

1.const对象只能访问const成员函数,而非const对象可以访问任意的成员函数

2.const成员函数不能修改对象的数据成员，const对象的成员变量不可以修改（mutable修饰的数据成员除外）

**注意**

1.两个成员函数如果只是常量性不同（有无const），是可以被重载的

2.当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本避免代码重复（使用转型，条款27提及）

## [条款04.确认对象被使用前已经被初始化](#contents)

1.为内置对象进行手工初始化；对于类类型，构造函数负责初始化

2.构造函数最好使用初始化列表进行初始化，而不是使用赋值操作；最好总是以声明次序为其初始化次序

3.不同编译单元的non-local static对象初始化相对次序并无明确定义，以local对象替换得以免除问题，例：
```C++
class Example { ... };
Example& emp()
{
    static Example emp;
    return emp;
}
```

**注意**

函数内的local static对象会在“该函数调用期间” “首次遇上该对象之定义式”时被初始化

# [Part-2.构造/析构/赋值运算](#contents)

## [条款05：了解C++默默编写并调用了哪些函数](#contents)

编译器会主动为编写的任何类**声明**一个拷贝构造函数、拷贝复制操作符和一个析构函数，同时如果你没有声明任何构造函数，编译器也会为你声明一个默认的的拷贝构造函数，这些函数都是public且inline的。注意，上边说的是声明，只有当这些函数有调用需求的时候，编译器才会帮你去实现它们。但是编译器替你实现的函数可能在类内引用、类内指针、有const成员以及类型有虚属性的情形下会出问题。

- 对于拷贝构造函数，要考虑到类内成员有没有**深拷贝**的需求，如果有的话就需要自己编写拷贝构造函数/操作符，而不是把这件事情交给编译器来做。
- 对于拷贝构造函数，如果类内有**引用成员或const成员**，需要自己定义拷贝行为，因为编译器实现的拷贝行为在上述两个场景很有可能是有问题的。
- 对于析构函数，如果该类有多态需求，请主动将析构函数声明为virtual，具体请看条款07 。

除了这些特殊的场景以外，如果不是极其简单的类型，编写好构造、析构、拷贝构造和赋值操作符、移动构造和赋值操作符（C++11、如有必要）这六个函数

## [条款06：若不想使用编译器自动生成的函数，就该明确拒绝。](#contents)

承接上一条款，如果你的类型在语义或功能上需要明确禁止某些函数的调用行为，比如禁止拷贝行为，那么就应该禁止编译器去自动生成它。作者在这里给出了两种方案来实现这一目标：

1. 将被禁止生成的函数声明为**private**并**省略实现**，这样可以禁止来自类外的调用。但是如果类内不小心调用了（成员函数、友元），那么会得到一个链接错误。
2. 将上述的可能的链接错误转移到编译期间。设计一个不可拷贝的工具基类，将真正不可拷贝的基类私有继承该基类型即可，但是这样的做法过于复杂，对于已经有继承关系的类型会引入多继承，同时让代码晦涩难懂
3. 对于C++11，我们可以直接使用= delete来声明拷贝构造函数，显示禁止编译器生成该函数。

## [条款07：为多态基类声明virtual](#contents)

该条款的核心内容为：**带有多态性质的基类必须将析构函数声明为虚函数，防止指向子类的基类指针在被释放时只局部销毁了该对象**。如果一个类有多态的内涵，那么几乎不可避免的会有基类的指针（或引用）指向子类对象，因为非虚函数没有动态类型，所以如果基类的析构函数不是虚函数，那么在基类指针析构时会直接调用基类的析构函数，造成子类对象仅仅析构了基类的那一部分，有内存泄漏的风险。除此之外，还需注意：

1. 普通的基类无需也不应该有虚析构函数，因为虚函数无论在时间还是空间上都会有代价，详情《More Effective C++》条款24
2. 如果一个类型没有被设计成基类，又有被误继承的风险，请在类中声明为final（C++11中用于禁止该类被继承），这样禁止派生可以防止误继承造成上述问题。
3. 编译器自动生成的析构函数是非虚的，所以多态基类必须将析构函数显示声明为virtual。

## [条款08：别让异常逃离析构函数](#contents)

析构函数一般情况下不应抛出异常，因为很大可能发生各种未定义的问题，包括但不限于内存泄露、程序异常崩溃、所有权被锁死等。

一个直观的解释：析构函数是一个对象生存期的最后一刻，负责许多重要的工作，如线程，连接和内存等各种资源所有权的归还。如果析构函数执行期间某个时刻抛出了异常，就说明**抛出异常后的代码无法再继续执行**，这是一个非常危险的举动——因为析构函数往往是为类对象兜底的，甚至是在该对象其他地方出现任何异常的时候，析构函数也有可能会被调用来给程序擦屁股。在上述场景中，如果在一个异常环境中执行的析构函数又抛出了异常，很有可能会让程序直接崩溃，这是每一个程序员都不想看到的。

如果某些操作真的很容易抛出异常，如资源的归还等，并且你又不想把异常吞掉，那么就请把这些操作移到析构函数之外，提供一个普通函数做类似的清理工作，在析构函数中只负责记录，我们需要时刻保证析构函数能够执行到底。

## [条款09：绝不在构造和析构过程中调用virtual函数。](#contents)

在多态环境中，我们需要重新理解构造函数和析构函数的意义，这两个函数在执行过程中，涉及到了对象类型从基类到子类，再从子类到基类的转变。

一个子类对象开始创建时，首先调用的是基类的构造函数，在调用子类构造函数之前，该对象将一直保持着“基类对象”的身份而存在，自然**在基类的构造函数中调用的虚函数——将会是基类的虚函数版本**。在子类的构造函数中，原先的基类对象变成了子类对象，这时子类构造函数里调用的是子类的虚函数版本。这是一件有意思的事情，这说明在构造函数中虚函数并不是虚函数，在不同的构造函数中，调用的虚函数版本并不同，因为随着不同层级的构造函数调用时，对象的类型在实时变化。那么相似的，析构函数在调用的过程中，子类对象的类型从子类退化到基类。

因此，如果指望在基类的构造函数中调用子类的虚函数，那就趁早打消这个想法。但很遗憾的是，你可能并没有意识到自己做出了这样的设计，例如将构造函数的主要工作抽象成一个init()函数以防止不同构造函数的代码重复是一个很常见的做法，但是在init()函数中是否调用了虚函数，就要好好注意一下了，同样的情况在析构函数中也是一样。

## [条款10：令operator =返回一个reference to *this](#contents)

简单来说：这样做可以让赋值操作符实现“连等”的效果：
````c++
x = y = z = 10;
````
在设计接口时一个重要的原则是，让自己的接口和内置类型相同功能的接口尽可能相似，所以如果没有特殊情况，就让赋值操作符的返回类型为`ObjectClass&`类型并在代码中返回`*this`。

## [条款11：在operator=中处理“自我赋值”](#contents)

自我赋值指的是将自己赋给自己。这是一种看似愚蠢无用但却在代码中出现次数比任何人想象的多得多的操作，这种操作常常需要借指针来实现：

````C++
*pa = *pb;		 		//pa和pb指向同一对象，便是自我赋值。
arr[i] = arr[j];		//i和j相等，便是自我赋值
````

那么对于管理一定资源的对象重载的operator= 中，一定要对是不是自我赋值格外小心并且增加预判，因为无论是深拷贝还是资源所有权的转移，原先的内存或所有权一定会被清空才能被赋值，如果不加处理，这套逻辑被用在自我赋值上会发生**先把自己的资源给释放掉了，然后又把已释放掉的资源赋给了自己**这样的错误。

第一种做法是在赋值前增加预判，但是这种做法没有异常安全性，试想如果在删除掉原指针指向的内存后，在赋值之前任何一处跑出了异常，那么原指针就指向了一块已经被删除的内存。

````C++
SomeClass& SomeClass::operator=(const SomeClass& rhs) {
      if (this == &rhs) 
		return *this;  
      delete ptr;	
      ptr = new DataBlock(*rhs.ptr);				//如果此处抛出异常，ptr将指向一块已经被删除的内存。
      return *this;
    }
````

如果把异常安全性也考虑在内，那么我们就会得到如下方法，令人欣慰的是这个方法也解决了自我赋值的问题。

````C++
SomeClass& SomeClass::operator=(const SomeClass& rhs) {
  DataBlock* pOrg = ptr;
  ptr = new DataBlock(*rhs.ptr);				//如果此处抛出异常，ptr仍然指向之前的内存。
  delete pOrg;
  return *this;
}
````

另一个使用copy and swap技术的替代方案将在条款29中作出详细解释。

## [条款12：复制对象时别忘了它的每一个成分](#contents)

1. 当给类多加了成员变量时，请不要忘记在拷贝构造函数和赋值操作符中对新加的成员变量进行处理。但如果你忘记处理，编译器也不会报错。
2. 如果你的类有继承，那么在你为子类编写拷贝构造函数时一定要格外小心复制基类的每一个成分，这些成分往往是private的，所以你无法访问它们，你应该让**子类使用子类的拷贝构造函数去调用相应基类的拷贝构造函数**：

````C++
//在成员初始化列表显示调用基类的拷贝构造函数
ChildClass::ChildClass(const ChildClass& rhs) : BaseClass(rhs) {		
  	// ...
}
````

除此之外，拷贝构造函数和拷贝赋值操作符，他们两个中任意一个不要去调用另一个，这虽然看上去是一个避免代码重复好方法，但是是荒谬的。其根本原因在于拷贝构造函数在构造一个对象——这个对象在调用之前并不存在；而赋值操作符在改变一个对象——这个对象是已经构造好了的。因此前者调用后者是在给一个还未构造好的对象赋值；而后者调用前者就像是在构造一个已经存在了的对象。不要这么做！

# [Part-3.资源管理](#contents)

## [条款13：以对象管理资源](#contents)

问题：以面向流程的方式管理资源（的获取和释放），总是会在各种意外出现时，丢失对资源的控制权并造成资源泄露。以面向过程的方式管理资源意味着，资源的获取和释放都分别被封装在函数中。这种管理方式意味着资源的索取者肩负着释放它的责任，但此时我们就要考虑一下以下几个问题：调用者是否总是会记得释放呢？调用者是否有能力保证合理地释放资源呢？不给调用者过多义务的设计才是一个良好的设计。

会造成释放资源出问题的原因有：

1. 一句简单的delete语句并不会一定执行，例如一个过早的return语句或是在delete语句之前某个语句抛出了异常
2. 谨慎的编码可能能在这一时刻保证程序不犯错误，但无法保证软件接受维护时，其他人在delete语句之前加入的return语句或异常重复第一条错误。

为了保证资源的获取和释放一定会合理执行，我们把获取资源和释放资源的任务封装在一个对象中。**当我们构造这个对象时资源自动获取，当我们不需要资源时，我们让对象析构**。这便是“Resource Acquisition Is Initialization; RAII”的想法，因为我们总是在获得一笔资源后于同一语句内初始化某个管理对象。无论控制流如何离开区块，一旦对象被销毁（比如离开对象的作用域）其析构函数会自动被调用。

具体实践请参考C++11的shared_ptr<T>。

## [条款14：在资源管理类小心copy行为](#contents)

一般资源管理类复制时可以选择以下做法：

1. 禁止复制（复制不合理）
2. “引用计数法”（使用tr1::shared_ptr指定“删除器”阻止引用次数为0时的删除行为）
3. 复制底层资源（“深度拷贝”）
4. 转移底部资源的拥有权（auto_ptr）


## [条款15：在资源管理类中提供对原始资源的访问](#contents)

- get成员函数实现显式转换（安全，受欢迎）
- 隐式转换函数（方便），例：

````C++
class Tmp{
public:
    ...
    operator TmpConvertType() const  //隐式转换函数
    { return t; }
    ...
private:
    TmpConvertType t;
};
````

## [条款16：成对使用new和delete要采用相同的格式](#contents)

- new和delete对应，new[ ]和delete[ ]对应

## [条款17：以独立的语句将newed对象置入智能指针](#contents)

- 在一个语句中编译器拥有重新排列操作的自由，如此一来可能被异常干扰，发生资源泄露

## [条款15：转移底部资源的拥有权（auto_ptr）](#contents)
## [条款15：转移底部资源的拥有权（auto_ptr）](#contents)
## [2.尽量以const，enum，inline替换 #define](#contents)
## [2.尽量以const，enum，inline替换 #define](#contents)
## [Performance](#contents)



Please check the official [homepage](https://gitee.com/mindspore/models).
