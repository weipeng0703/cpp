# 1. C++

## 1.1 C语言和C++的区别

**注意：一定不能单纯的认为C语言面向过程，C++面向对象。**

C++是至少四种编程范式的集合体（面向过程，面向对象，泛型编程和元编程，[函数式编程](https://www.zhihu.com/search?q=函数式编程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1698735362})等，实际可能不止4种）。说C++是面向对象语言，是一种很瞧不起C++的说法，因为面向对象仅仅是C++的多种范式之一；在面向对象方面，C语言提供的语法支持比较薄弱，但这不表示C是面向过程的语言。用C语言写面向对象程序不仅不弱，甚至会有一些优势。世界上有很多非常重要的、大量使用面向对象技术的软件是用纯C写的。例如Linux的图形界面GNOME。

１. C++ 有**新增的语法和关键字**，语法的区别有**头⽂件的不同**和**命名空间的不同**：

C++ 允许⾃⼰定义⾃⼰的空间，C 中不可以。

关键字⽅⾯⽐如 C++ 与 C 动态管理内存的⽅式不同，C++ 中在 malloc 和 free 的基础上增加了 new和 delete。

C++ 在指针的基础上增加了引⽤的概念。

关键字例如 C++中还增加了 auto，explicit 体现显式和隐式转换上的概念要求，还有 dynamic_cast 增加类型安全⽅⾯的内容。

２. 函数⽅⾯ **C++** 中有**重载**和**虚函数**的概念：C++ ⽀持函数重载⽽ C 不⽀持，是因为 C++ 函数的名字修饰与 C 不同，C++ 函数名字的修饰会将参数加在后⾯，例如，int func(int,double)经过名字修饰之后会变成_func_int_double，⽽ C 中则会变成 _func，所以 C++ 中会⽀持不同参数调⽤不同函数。

**C++** 还有虚函数概念，⽤以实现多态。

３. **类⽅⾯**，**C** 的 **struct** 和 **C++** 的类也有很⼤不同：C++ 中的 struct 不仅可以有成员变量还可以有成员函数，⽽且对struct 增加了权限访问的概念，struct 的默认成员访问权限和默认继承权限都是 public；C++ 中除了 struct 还有class 表示类，struct 和 class 还有⼀点不同在于 class 的默认成员访问权限和默认继承权限都是 private。

４. **C++** 中增加了**模板**还重用代码，提供了更加强⼤的 **STL** 标准库。（C++可复用性高）

最后补充⼀点就是 C 是⼀种结构化的语⾔，重点在于算法和数据结构。C 程序的设计⾸先考虑的是如何通过⼀个代码，⼀个过程对输⼊进⾏运算处理输出。⽽ C++ ⾸先考虑的是如何构造⼀个对象模型，让这个模型能够契合与之对应的问题领域，这样就能通过获取对象的状态信息得到输出。

## 1.2 C++和JAVA的区别

语言特性

1. Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强

2. Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题

   注：并⾮ Java 中没有指针，Java 虚拟机内部中还是⽤了指针，保证了Java 程序的安全。

3. C++也可以在其他系统运行，但是需要不同的编码，例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java只编写一次代码，到处运行：Java程序一般都是生成字节码，在JVM里面运行得到结果

4. Java用接口(Interface)技术取代C++程序中的抽象类。接口与抽象类有同样的功能，但是省却了在实现和维护上的复杂性

5. 多重继承：C++ ⽀持多重继承但 Java 不⽀持，但JAVA⽀持⼀个类继承多个接⼝，实现 C++ 中多重继承的功能，⼜避免了 C++ 的多重继承带来的不便。

6. 数据类型和类：Java 是完全⾯向对象的语⾔，所有的函数和变量必须是类的⼀部分。除了基本数据类型之外，其余

   的都作为类对象，对象将数据和⽅法结合起来，把它们封装在类中，这样每个对象都可以实现⾃⼰的特点和⾏为。

   Java 中取消了 C++ 中的 struct 和 union 。

垃圾回收

1. C++用析构函数回收垃圾，写C和C++程序时一定要注意内存的申请和释放

2. Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题

应用场景

1. Java在桌面程序上不如C++实用，C++可以直接编译成 .exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）

2. Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架

3. 对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在

## 1.3 C++面向对象的思想如何体现

1. 关于面向对象

![image-20220523222112755](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220523222112755.png)

2. C++中面向对象的三大特征——封装、继承与多态

![image-20220523222225560](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220523222225560.png)

（1）封装：数据和代码捆绑在一起，避免外界干扰和不确定性访问。

封装，也就是**把客观事物封装成抽象的类**，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。

（2）继承：常见的继承的方式

1. 实现继承：指使用基类的属性和方法而无需额外编码的能力

2. 接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力

3. 可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++里好像不怎么用）

例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法

（3）多态

同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为。

**（重载实现编译时多态，虚函数实现运行时多态）**。

多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。**简单一句话：允许将子类类型的指针赋值给父类类型的指针**

实现多态有两种方式——重写 / 覆盖（override）与 重载（overload）：

覆盖：是指子类重新定义父类的虚函数的做法。

重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。



## 1.4 内存泄漏相关问题

### 1. 定义

内存泄漏简单的说就是申请了⼀块内存空间，使⽤完毕后没有释放掉。 它的⼀般表现⽅式是程序运⾏时间越⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。

常说的内存泄漏是指**堆内存的泄漏**。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏。

（1）new和malloc申请资源使用后，没有用delete和free释放；

（2）子类继承父类时，父类析构函数不是虚函数。

（3）Windows句柄资源使用后没有释放。

[这篇文章](https://blog.csdn.net/hailong66666/article/details/122081264)解释delete的原理很好。

### 2. 如何检测

（1）⾸先可以通过观察猜测是否可能发⽣内存泄漏，Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。

（2）使⽤ 其他⼀些 /usr/bin/stat ⼯具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，⼀个可能的解释就是有个进程出现了内存泄漏。

（3）⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 valgrind 这样的⼯具来进⾏内存泄漏的检测。

**附：valgrind的原理是什么（valgrind包括很多工具，这里主要介绍工具memcheck的原理）**

1、memcheck主要检查的错误：

- 使用未初始化的内存(Use of uninitialised memory)
- 使用已经释放了的内存(Reading/writing memory after it has been free'd)
- 使用超过malloc分配的内存空间(Reading/writing off the end of malloc'd blocks)
- 对堆栈的非法访问(Reading/writing inappropriate areas on the stack)
- 申请的空间是否有释放(Memory leaks – where pointers to malloc'd blocks are lost forever)
- malloc/free/new/delete申请和释放内存的匹配(Mismatched use of malloc/new/new [] vs free/delete/delete [])
- src和dst的重叠(Overlapping src and dst pointers in memcpy() and related functions)

2、基本原理：memcheck实现了一个仿真的CPU，被监控的程序被这个仿真CPU解释执行，从而有机会在所有的内存读写指令发生的时候，检测地址的合法性和读操作的合法性。

（1）如何知道那些地址是合法的（内存已分配）？

维护一张合法地址表（Valid-address(A) bits），当前所有可以合法读写（已分配）的地址在其中有对应的表项。该表通过以下措施维护:

全局数据(data, bss section)--在程序启动的时候标记为合法地址
局部变量--监控sp(stack pointer)的变化，动态维护
动态分配的内存--截获 分配/释放 内存的调用 ：malloc, calloc, realloc, valloc, memalign, free, new, new[], delete and delete[]
系统调用--截获mmap映射的地址
其他--可以显示知会memcheck某地字段是合法的

（2）如何知道某内存是否已经被赋值？

维护一张合法值表（Valid-value (V) bits），指示对应的bit是否已经被赋值。因为虚拟CPU可以捕获所有对内存的写指令，所以这张表很容易维护。

3、局限：

-memcheck无法检测global和stack上的内存溢出，因为溢出的地方也在Valid-address (A) bits中。这是由memcheck 的工作原理决定的。

-慢，20到30倍，被虚拟CPU解释一遍，当然慢

-内存占用高，因为要维护两张表格，而这两张表的维度正比于程序的内存



### 3. 如何避免

第一：良好的编码习惯：使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉；有new就有delete，有malloc就有free，保证它们一定成对出现；一定要将基类的析构函数声明为**虚函数**；对象数组的释放一定要用

**delete []**

第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查该链表

第三：使用智能指针。

第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind（Linux下的），CRT库(Windows下的)等等。

### 4. 不用delete是不是一定会出问题

如果我们new的不是对象而是内置类型，或者说对象中并不含有指向其他堆内存的指针，那么理论上来说就算不使用delete也不会造成内存泄漏。

但是我们平时还是要遵守，这是一个好的习惯，搭配起来的话就不会出现各种各样奇怪的问题，这其实是对自己好。

### 5. 访问越界，访问到什么数据

![image-20220523224651512](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220523224651512.png)

​		![image-20220523224706785](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220523224706785.png)

![image-20220523224720482](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220523224720482.png)



## 1.5 栈和堆的区别

1. 申请和管理方式

   堆中资源由程序员控制，需要⼿动 new malloc delete free 进⾏分配和回收，如果不进⾏回收的话，会造成内存泄漏的问题。

   栈资源由编译器自动管理，在需要时由编译器⾃动分配空间，在不需要时候⾃动回收空间，⼀般保存的是局部变量和函数参数等。

2. 内存管理机制

   对于堆：系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分

   配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）

   对于栈：只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一

   下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了）

3. 空间大小

   堆：堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中

   有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大（1G ~ 4G）

   栈：栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置）

4. 碎片问题

   对于堆，频繁的new/delete会造成大量碎片，使程序效率降低

   对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（堆和栈的区别与栈和队列的区别）

5. 生长方向

   堆向上，向高地址方向增长。 

   栈向下，向低地址方向增长。

6. 分配方式

   堆都是动态分配（没有静态分配的堆） 

   栈有静态分配和动态分配：

   ​	静态分配由编译器完成（如局部变量分配）

   ​	动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。

7. 分配效率

   堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

   操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。

8. 缓存方式

   栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；

   堆则是存放在二级缓存中，速度要慢些。



## 1.6 前后＋＋的区别

![image-20220523232614706](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220523232614706.png)





## 1.7 重载、重写与隐藏

### 1.7.1 三者的区别

（1）重载 overload

重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：

```c++
class A{
 ...
 virtual int fun();
 void fun(int);
 void fun(double, double);
 static int fun(char);
 ...
}
```



（2）重写/覆盖 override

重写指的是在派生类中覆盖基类中的同名函数，**重写就是重写函数体**，**要求基类函数必须是虚函数**,且与基类的虚函数有相同的参数个数、参数类型和返回值类型相同。举个例子：

```c++
//父类
class A{
public:
 virtual int fun(int a){}
}
//子类
class B : public A{
public:
 //重写,一般加override可以确保是重写父类的函数
 virtual int fun(int a) override{}
}
```

重载与重写的区别：

​	重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系

​	重写要求参数列表相同，重载则要求参数列表不同，返回值不要求

​	重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体

(3)隐藏 hide

隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：

1-两个函数参数相同，但是基类函数不是虚函数。**和重写的区别在于基类函数是否是虚函数。**举个例

子：

```C++
//父类
class A{
public:
 void fun(int a){
 cout << "A中的fun函数" << endl;
 }
};
//子类
class B : public A{
public:
 //隐藏父类的fun函数
 void fun(int a){
 cout << "B中的fun函数" << endl;
 }
};
int main() {
 B b;
 b.fun(2); //调用的是B中的fun函数
 b.A::fun(2); //调用A中fun函数
 return 0; 
}
```

2-**两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：**

```C++
//父类
class A{
public:
 virtual void fun(int a){
 cout << "A中的fun函数" << endl;
 }
};
//子类
class B : public A{
public:
 //隐藏父类的fun函数
 virtual void fun(char* a){
 cout << "A中的fun函数" << endl;
 }
};
int main(){
 B b;
 b.fun(2); 	   	//报错，调用的是B中的fun函数，参数类型不对
 b.A::fun(2); 	//调用A中fun函数
 return 0; }
```

### 1.7.2 C++中的重载和重写如何实现

（１）重载：C++利用命名倾轧（name mangling）技术，来更改函数名，区分参数不同的同名函数。命名倾轧是在**编译**阶段完成的。

![image-20220525204426189](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220525204426189.png)

（２）重写：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

1.用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。

2.存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。

3.多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。

4.重写用虚函数来实现，结合动态绑定。

5.纯虚函数是虚函数再加上 = 0。

6.抽象类是指包括至少一个纯虚函数的类。

7.纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。



### 1.7.3 C 语言如何实现C++中重载的效果

c语言中不允许有同名函数，因为编译时函数命名是一样的，不像c++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：

​	1.使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能

​	2.重载函数使用可变参数，方式如打开文件open函数

​	3.gcc有内置函数，程序使用编译函数可以实现函数重载





## 1.8 多态及其实现，静态绑定与动态绑定

### 1-多态及其实现（详见阿秀3.5 -1）

同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为。

**（重载实现编译时多态，虚函数实现运行时多态）**。

多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。**简单一句话：允许将子类类型的指针赋值给父类类型的指针**

实现多态有两种方式——重写 / 覆盖（override）与 重载（overload）：

​	重写：是指子类重新定义父类的虚函数的做法。

​	重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。

### 2-静态绑定与动态绑定

静态类型：对象在声明时采用的类型，在编译期确定；

动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；

静态绑定(早绑定)：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；

动态绑定(晚绑定)：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。举个例子

```C++
#include <iostream>
using namespace std;
class A {
public:
 /*virtual*/ void func() { std::cout << "A::func()\n"; }
};
class B : public A {
public:
 void func() { std::cout << "B::func()\n"; }
};
class C : public A
{
public:
 void func() { std::cout << "C::func()\n"; }
};
int main()
{
 C* pc = new C(); //pc的静态类型是它声明的类型C*，动态类型也是C*；
 B* pb = new B(); //pb的静态类型和动态类型也都是B*；
 A* pa = pc; //pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；
 pa = pb; //pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候
的A*；
 C *pnull = NULL; //pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；
 
 pa->func(); //A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调
用A::func()；
 pc->func(); //C::func() pc的动、静态类型都是C*，因此调用C::func()；
 pnull->func(); //C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定
了，和指针空不空没关系；
 return 0; }
```

但是如果将A类中的virtual注释掉，运行结果则是

```C++
pa->func(); //B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；
pc->func(); //C::func() pc的动、静态类型都是C*，因此也是先在C中查找；
pnull->func(); //空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；
```

在上面的例子中，

(1)如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。

(2)同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此**静态绑定不能实现多态**；

(3)如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；

### 3-引用是否能实现动态绑定，为什么可以实现？

引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。

```C++
#include <iostream>
using namespace std;
class Base {
public:
 virtual void fun() {
 	cout << "base :: fun()" << endl;
 }
};
class Son : public Base {
public:
 virtual void fun() {
 	cout << "son :: fun()" << endl;
  }
 void func() {
 	cout << "son :: not virtual function" <<endl;
 }
};
int main() {
 Son s;
 Base& b = s; // 基类类型引用绑定已经存在的Son对象，引用必须初始化
 s.fun(); //son::fun()
 b.fun(); //son :: fun()
 return 0;	
}
// 需要说明的是虚函数才具有动态绑定，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。
```



## 1.9 抽象类与纯虚函数及其作用，纯虚函数是否有函数体，是否编译

### 1-抽象类

1、定义

抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层，称带有纯虚函数的类为抽象类。

2、作用

抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。

3、特点

抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。

如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。

抽象类不能用作参数类型、函数返回类型或显示转换的类型

可以定义指向抽象类的指针和引用，指针可以指向其派生类从而实现多态

### 2-纯虚函数

1、定义

纯虚函数是一种特殊的虚函数，它是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0。定义如下：

```C++
class <类名> { virtual <类型><函数名>(<参数表>)=0; … };
```

2、引入原因

 1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。

 2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。

因此在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。

纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。

3、纯虚函数与虚函数的区别

虚函数是为了实现**动态编联**产生的，目的是**通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数**（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。

纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。

![image-20220525213451081](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220525213451081.png)

4、纯虚函数是否有函数体

纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“=0”。

既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。

5、纯虚函数是否被编译

另一个问题是 early binding 和 late binding 的问题。非虚函数都是在编译期确定的，所以都是早绑定（静态绑定，编译期绑定）；虚函数理论上我们认为它是晚绑定（动态绑定，运行时绑定）的，但如果编译器能在编译阶段确定类型，这种情况下也能早绑定，例如，在构造函数和析构函数里，或者在最终派生类上直接调用虚函数等。

6、**纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？**

1.纯虚函数不可以实例化，但是可以用其派生类实例化

```c++
class Base {
 public:
    virtual void fun() = 0;
};
class Derived : public Base {
 public:
    void fun() {
    	cout << "hello" << endl;
    }
};
int main() {
    Base *b = new Derived();
    b->fun();
    return 0;
}
```

2.虚函数的原理采用vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。

即"纯虚函数在类的vtable表中对应的表项被赋值为0, 也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。” 所以纯虚函数不能实例化。

3.纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。

4.定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它"。



## 1.10 虚函数与虚函数表

**1、虚函数的实现原理**

C++中多态的表象，在基类的函数前加上 virtual 关键字，在派⽣类中重写该函数，运⾏时将会 根据对象的实际类型来调⽤相应的函数。如果对象类型是派⽣类,就调⽤派⽣类的函数；如果是基类，就调⽤基类 的函数。

 实际上,当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址。同样派⽣类 继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成⾃⼰的虚函数表。当我们定义⼀个派⽣类对象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的.。

后续如果有⼀个基类类型的指针指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。

**2、虚函数表**

虚函数表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚函数表，所以虚函数表的元素并不包括普通函数的函数指针。
虚函数表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚函数表就可以构造出来了。

附：虚函数表何时写入

![image-20220526164207302](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526164207302.png)

**3.虚函数表指针**

虚函数表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚函数表即可。同一个类的所有对象都使用同一个虚函数表。
为了指定对象的虚函数表，对象内部包含一个虚函数表的指针，来指向自己所使用的虚函数表。为了让每个包含虚函数表的类的对象都拥有一个虚函数表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚函数表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚函数表。

**4、虚函数表指针位置**

![image-20220525215610175](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220525215610175.png)

注：上图中是在64位环境下，int与指针大小均为8

![image-20220525215629423](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220525215629423.png)

**5、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间**

虚函数表的特征：

（1）虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成

（2）虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段

（3）虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中

根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区。

由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。

一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区

C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型的常量区；

虚函数位于代码段(.text)，也就是内存模型的代码区。

**6、哪些函数不能是虚函数**

1) 构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；

2) 内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；

3) 静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。

4) 友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。

5) 普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。



## 1.11 C++的内存分区和可执行程序的分段（内存管理） 

### 1、内存的五大分区（程序运行时，存储区如何划分）

栈：由编译器管理分配和回收，存放局部变量和函数形参。

堆（记忆位置时理解为向上堆，往上放往上增长）：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎⽚的情况。

全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。

常量存储区：存储常量，⼀般不允许修改。例如：通过#define、const定义的常量， 源代码中以指针形式定义的字符串

代码区：存放程序的⼆进制代码。

![image-20220525221022839](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220525221022839.png)

### 2、初始化为0的全局变量在哪里？

.BSS段;

.BSS段通常是指用来存放程序中**未初始化的或者初始化为0的全局变量和静态变量**的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。

### 3、可执行程序程序三段-Text段，Date段，Bss段

![image-20220526200246600](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526200246600.png)

text段在内存中被映射为只读，date段与bss段是可写的
1. text段：代码段，就是放程序代码的，编译时确定，只读
2. date段：存放在编译阶段（而非运行时）就能确定的数据，可读可写。也就是通常所说的静态存储区，赋了初值的全局变量和赋初值的静态变量存放在这个区域，常量也存在这个区域
3. bss段：已经定义但没赋初值的全局变量和静态变量存放在这个区域。
两者之间区别是：代码段，数据段，堆栈段是CPU级别的概念，五大分区属于语言级别的概念，两者是不同的概念。

### 4、可执行程序内存空间与逻辑地址空间的映射与划分

![image-20220526202458651](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526202458651.png)

1. 首先是栈区（堆栈区stack）,堆栈是由编译器自动分配释放，存放函数的参数形参和局部变量的值（auto类型），操作方式类似于数据结构中的栈。栈的申请是由系统自动分配，如在函数内部申请一个局部变量int h,同时判断所申请空间是否小于栈的剩余空间，如果小于则为其开辟空间，为程序提供内存，否则将报异常提示栈溢出。
2. 堆（heap），堆一般由程序员分配释放，若程序员不释放，程序结束可能由OS回收。它与数据结构中的堆是两回事，分配方式类似于链表，申请则是程序员自己操作使用malloc或new。申请过程比较复杂，当系统收到程序的申请时，会遍历记录空闲内存地址的链表，以求寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序，有些情况下，新申请的内存块的首地址记录本次分配的内存块的大小，这样在delete尤其是delete[]时能正确的释放内存空间。
3. 下边是全局静态存储区，全局变量与静态变量的存储是放在一块的，初始化的全局变量与静态变量存放在一块区域，未初始化的全局变量与未初始化的静态变量存放在相邻的另一块区域。
4.  文字常量区，常量字符串就是放在该部分，只读存储区，程序结束后由系统释放
5.  程序代码区，存放程序的二进制代码区。

### 5、存储类型关键字定义变量与函数作用域与生命周期

![image-20220526202859990](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526202859990.png)

1. auto变量：函数的局部变量，如果没有声明为static，函数中定义的局部变量**全部为auto类型**，auto变量包括未加static声明的局部变量和函数的形参。在函数调用时系统会给他们分配存储空间，在函数调用结束后会自动释放这些空间。属于动态存储方式。
2. static变量：用static声明的局部变量在调用结束后不会消失而保存原来的值。static局部变量定义使用后值会存储下来。所以使用static局部变量定义只需要一次赋值。静态局部变量的作用域仅限于所定义的函数，但函数结束后变量的值会保留。直到整个程序运行结束。全局变量从定义开始作用于整个文件直至程序运行结束。
3. register寄存器变量：寄存器变量可以提高c语言的执行效率，即将局部变量的值存入CPU的寄存器中。需要注意的是！！！：1.只有动态存储的变量（自动局部变量和形参）才可以作为寄存器变量来存储，局部静态变量不可以定义为寄存器变量。2.计算机的寄存器数目是有限的，所以不能定义任意多个寄存器变量。
4. extern外部变量：即全局变量的外部表现形式，是在函数外部定义的变量。全局变量的作用域为从定义开始到源文件结束。extern对该变量作外部变量声明，**扩展变量作用域**。

### 6、常见的内存错误及对策

![image-20220527161152368](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527161152368.png)

## 1.12 static

1、作用——控制变量的存储方式和可见性

**作⽤⼀：修饰局部变量**（两变一不变）：⼀般情况下，对于局部变量在程序中是存放在栈区的，并且局部的⽣命周期在包含语句块执⾏结束时便结束了。但是如果⽤ static 关键字修饰的话，该变量便会存放在静态数据区，其⽣命周期会⼀直延续到整个程序执⾏结束。但是要注意的是，虽然⽤ static 对局部变量进⾏修饰之后，其**⽣命周期以及存储空间**发⽣了变化，但其**作⽤域**并没有改变，作⽤域还是限制在其语句块。

**作⽤⼆：修饰全部变量**：对于⼀个全局变量，它既可以在本⽂件中被访问到，也可以在同⼀个⼯程中其它源⽂件被访问(添加 extern进⾏声明即可)。⽤ static 对全局变量进⾏修饰改变了其作⽤域范围，由原来的整个⼯程可⻅变成了本⽂件可⻅。

**作⽤三：修饰函数**：⽤ static 修饰函数，情况和修饰全局变量类似，也是改变了函数的作⽤域。

**作⽤四：修饰类**：如果 C++ 中对类中的某个函数⽤ static 修饰，则表示该函数属于⼀个类⽽不是属于此类的任何特定对象；如果对类中的某个变量进⾏ static 修饰，则表示该变量以及所有的对象所有，存储空间中只存在⼀个副本，可以通过 类和对象去调⽤。（补充：静态⾮常量数据成员，其只能在类外定义和初始化，在类内仅是声明⽽已。）

**作⽤五：类成员/类函数声明 static**

函数体内 static 变量的作⽤范围为该函数体，不同于 auto 变量，该变量的内存只被分配⼀次，因此其值在下次调⽤时仍维持上次的值；

在模块内的 static 全局变量可以被模块内所⽤函数访问，但不能被模块外其它函数访问； 

在模块内的 static 函数只可被这⼀模块内的其它函数调⽤，这个函数的使⽤范围被限制在声明它的模块内； 

在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有⼀份拷⻉； 

在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因⽽只能访问类的 static 成员变量；

static 类对象必须要在类外进⾏初始化，static 修饰的变量先于对象存在，所以 static 修饰的变量要在类外初始化；

由于 static 修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 this 指针，this 指针是指向本对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问⾮ static 的类成员，只能访问 static修饰的类成员；

static 成员函数不能被 virtual 修饰，static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意义；静态成员函数没有 this 指针，虚函数的实现是为每⼀个对象分配⼀个 vptr 指针，⽽ vptr 是通过 this 指针调⽤的，所以不能为 virtual；虚函数的调⽤关系，this->vptr->ctable->virtual function。

2、作用(笼统概括)

1.第一条也是最重要的一条：隐藏。（static函数，static变量均可）。当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。

2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。

3.static的第三个作用是默认初始化为0（static变量）。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。

4.static的第四个作用：同上作用5

3、static变量初始化的时机

存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。.BSS段通常是指用来存放程序中**未初始化的或者初始化为0的全局变量和静态变量**的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。

![image-20220525223000041](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220525223000041.png)

![image-20220526083217193](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526083217193.png)

![image-20220526091620229](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526091620229.png)







## 1.13 给定类，判断大小，包括空类，加入static，加入虚函数，考虑到内存对齐

1、计算原则

与类大小有关的因素：普通成员变量，[虚函数](https://so.csdn.net/so/search?q=虚函数&spm=1001.2101.3001.7020)，继承（单一继承，多重继承，重复继承，虚拟继承）

与类大小无关的因素：[静态成员](https://so.csdn.net/so/search?q=静态成员&spm=1001.2101.3001.7020)变量，静态成员函数及普通成员函数

2、空类

```C++
class Base {};
```

空类即什么都没有的类，按上面的说法，照理说大小应该是0，但是，空类的大小为1，因为空类可以实例化，实例化必然在内存中占有一个位置，因此，编译器为其优化为一个字节大小。

某个类继承自空类

```C++
class base
{
};
class derived:public base
{
 private:
    int a;
};
```

此时，derived类的大小为4，derived类的大小是自身int成员变量的大小，至于为什么没有加上父类base的大小1是因为空白基优化的问题，在空基类被继承后，子类会优化掉基类的1字节的大小，节省了空间大小，提高了运行效率

3、一般类的大小（注意内存对齐）

```c++
class base1 {
private:
    char a;
    int b;
    double c;
};
class base2 {
private:
    char a;
    double b;
    int c;
};
```

![image-20220526084205436](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526084205436.png)

4、包含普通成员函数的一般非空类

```C++
class Base {
    int val;
    char ch;
    void fun(){}
};
```

sizeof（Base）等于8。类的大小只与它的数据成员有关，与普通成员函数、构造函数、析构函数无关。

5、包含虚函数的类

```C++
class Base {
    int val;
    char ch;
    virtual void fun(){}
};
```

sizeof（Base）等于12。Base定义了一个虚函数，编译时会生成虚函数表，该类型的实例都包含一个指向虚函数表的指针，这个指向虚函数表的指针保存在实例内存中的最前面的位置，根据内存对齐的原则，Base的大小为12个字节。

6、包含静态数据成员的类别

```C++
class Base {
    int val;
    char ch;
    static int num;
};
```

sizeof（Base）等于8。因为静态数据成员保存在全局静态数据区，该类型的所有实例共享同一个静态数据成员，静态数据成员只分配一次内存。因此，Base的大小为8个字节。

7、单继承的类

```C++
class Base {
    int val;
    char ch;
};
class Derive： public Base {
    char c;
};
```

sizeof（Derive）等于12。Base的大小为8个字节，内存对齐值为4个字节，因此在Derive中相当于包含两个成员，类型分别为Base、char，根据内存对齐，对齐值为4，Derive的大小为12个字节。

8、含虚函数的单一继承 (64位，指针大小8字节)

```C++
class Base {
private:
    char a;
public:
    virtual void f();
    virtual void g();
};
class Derived:public Base {
private:
    int b;
public:
    void f();
};
class Derived1:public Base {
private:
    double b;
public:
    void g();
    virtual void h();
};
```

![image-20220526084758046](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526084758046.png)

![image-20220526085416814](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526085416814.png)

![image-20220526085502928](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526085502928.png)

9、含虚函数的多继承

```C++
class Base1 {
private:
    char a;
public:
    virtual void f();
    virtual void g1();
};
class Base2 {
private:
    int b;
public:
    virtual void f();
    virtual void g2();
};
class Base3 {
private:
    double c;
public:
    virtual void f();
    virtual void g3();
};
class Derived:public Base1, public Base2, public Base3 {
private:
    double d;
public:
    void f();
    virtual void derived_func();
};
```

![image-20220526085612901](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526085612901.png)

首先，Derived类自己的虚函数表指针与其声明继承顺序的**第一个基类**Base1的虚函数表指针合并，此外，若Derived类重写了基类中同名的虚函数，则在三个虚函数表的对应项都应该予以修改，**Derived中新添加的虚函数位于第一个虚函数表项后面，Derived中新添加的成员变量位于类的最后面**，按其声明顺序与内存对齐原则进行排列。

10、菱形继承的问题及解决方案：虚拟继承

[C++类大小详尽讲解](https://blog.csdn.net/longjialin93528/article/details/80160467?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-80160467-blog-102457472.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-80160467-blog-102457472.pc_relevant_paycolumn_v3&utm_relevant_index=1)



## 1.14 指针和引用的区别

1、二者的区别

1. 指针是一个变量（实体），存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
2. 指针可以有多级，引用只有一级
3. 指针可以为空，引用不能为NULL且在定义时必须初始化
4. 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。
5. 指针在初始化后可以改变指向，而引用在初始化之后不可再改变（变量可以被引用为多次，但引用只能作为一个变量引用）
6. sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小；在参数传递中，指针需要被解引用后才可以对对象进行操作，而直接对引用进行修改会做用到对象本身；
7. 作为参数时也不同,传指针的实质是**传值**,传递的值是指针的地址；传引⽤的实质是**传地址**,传递的是变量的地址；
8. 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（具体情况还要具体分析）。
9. 指针它指向⼀块内存,指针的内容是所指向的内存的地址,在编译的时候,则是将“指针变量名-指针变量的地址”添 加到符号表中,所以说,指针包含的内容是可以改变的,允许拷⻉和赋值,有 const 和⾮ const 区别,甚⾄可以为 空,sizeof 指针得到的是指针类型的⼤⼩. 
10. ⽽对于引⽤来说,它只是⼀块内存的别名,在添加到符号表的时候,是将"引⽤变量名-引⽤对象的地址"添加到符号 表中,符号表⼀经完成不能改变,所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上,后续不能更改,也不能为空,也没有 const 和⾮ const 区别.

2、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？

1. 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的

2. 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小

3. 类对象作为参数传递的时候使用引用，这是C++**类对象传递的标准方式**



## 1.15 构造函数和析构函数能否定义为虚函数

1、析构函数⼀般写成虚函数（虚析构）的原因

直观的讲：是为了降低内存泄漏的可能性.

由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成**内存泄漏**。

所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。

**析构函数可以是纯虚函数**，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。

2、构造函数不能定义成虚函数的原因（但构造函数内可以调用虚函数）

i.从存储空间角度:虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数,就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。(悖论)

ii.从使用角度:虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就要初始化实例，那使用虚函数也没有实际意义。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。

iii.从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型(因为子类会调父类的构造函数);而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。

3、构造或析构函数中调用虚函数会怎样

实际上是不应该在构造函数或析构函数中调⽤虚函数的,因为这样的调⽤其实并不会带来所想要的效果. 

举例来说就是,有⼀个动物的基类,基类中定义了⼀个动物本身⾏为的虚函数 action_type(),在基类的构造函数中 调⽤了这个虚函数.

派⽣类中重写了这个虚函数,我们期望着根据对象的真实类型不同,⽽调⽤各⾃实现的虚函数,但实际上当我们创 建⼀个派⽣类对象时,⾸先会创建派⽣类的基类部分,执⾏基类的构造函数,此时,派⽣类的⾃身部分还没有被初 始化,对于这种还没有初始化的东⻄,C++选择当它们还不存在作为⼀种安全的⽅法. 

也就是说构造派⽣类的基类部分是,编译器会认为这就是⼀个基类类型的对象,然后调⽤基类类型中的虚函数实 现,并没有按照我们想要的⽅式进⾏.即对象在派⽣类构造函数执⾏前并不会成为⼀个派⽣类对象. 

在析构函数中也是同理,派⽣类执⾏了析构函数后,派⽣类的⾃身成员呈现未定义的状态,那么在执⾏基类的析构 函数中是不可能调⽤到派⽣类重写的⽅法的.所以说,我们不应该在构在函数或析构函数中调⽤虚函数,就算调⽤ ⼀般也不会达到我们想要的结果.



## 1.16 enable_if

1、定义

C++11中引入了std::enable_if函数，enable_if 的主要作用就是当某个 condition 成立时，enable_if可以提供某种类型。enable_if在标准库中通过结构体模板实现的，声明(原型)如下：

```C++
template< bool Condition, class T = void >
struct enable_if;
```

可能的函数实现为：

```C++
template<bool B, class T = void>
struct enable_if {};
 
template<class T>
struct enable_if<true, T> { typedef T type; };
```

由上可知，只有当第一个模板参数为true时，enable_if会包含一个type=T的公有成员，否则没有该公有成员。

头文件:

```C++
#include <type_traits>
```

2、使用场景

1. **限制模板函数的参数类型**

   在某些场景下，我们需要实现只有特定类型可以调用的模板函数。如下代码所示，通过对返回值使用std::enable_if和在模板参数中使用std::enable_if均实现了只允许整形参数调用函数的功能。

   ```C++
   // enable_if example: two ways of using enable_if
   #include <iostream>
   #include <type_traits>
   
   // 1. the return type (bool) is only valid if T is an integral type:
   template <class T>
   typename std::enable_if<std::is_integral<T>::value,bool>::type
    is_odd (T i) {return bool(i%2);}
   
   // 2. the second template argument is only valid if T is an integral type:
   template < class T, class = typename std::enable_if<std::is_integral<T>::value>::type>
   bool is_even (T i) {return !bool(i%2);}
   
   int main() {
   
       short int i = 1;  // code does not compile if type of i is not integral
   
       std::cout << std::boolalpha;
       std::cout << "i is odd: " << is_odd(i) << std::endl;
       std::cout << "i is even: " << is_even(i) << std::endl;
   
       return 0;
   }
   ```

当使用float类型参数调用函数时，程序会报错：

```C++
error: no matching function for call to 'is_odd(float&)'
```



2. 在使用模板编程时，可以利用std::enable_if的特性根据模板参数的不同特性进行不同的类型选择。

   如下所示，我们可以实现一个检测变量是否为智能指针的实现：

```C++
#include <iostream>
#include <type_traits>
#include <memory>

template <typename T>
struct is_smart_pointer_helper : public std::false_type {};

template <typename T>
struct is_smart_pointer_helper<std::shared_ptr<T> > : public std::true_type {};

template <typename T>
struct is_smart_pointer_helper<std::unique_ptr<T> > : public std::true_type {};

template <typename T>
struct is_smart_pointer_helper<std::weak_ptr<T> > : public std::true_type {};

template <typename T>
struct is_smart_pointer : public is_smart_pointer_helper<typename std::remove_cv<T>::type> {};

template <typename T>
typename std::enable_if<is_smart_pointer<T>::value, void>::type check_smart_pointer(const T& t) {
    std::cout << "is smart pointer" << std::endl;
}

template <typename T>
typename std::enable_if<!is_smart_pointer<T>::value, void>::type check_smart_pointer(const T& t) {
    std::cout << "not smart pointer" << std::endl;
}

int main() {
    int* p(new int(2));
    std::shared_ptr<int> pp(new int(2));
    std::unique_ptr<int> upp(new int(4));

    check_smart_pointer(p);
    check_smart_pointer(pp);
    check_smart_pointer(upp);

    return 0;
}
```

程序输出：

```C++
not smart pointer
is smart pointer
is smart pointer
```





## 1.17 模板是如何实现的，模板特化、模板偏特化

### 1、模板是什么，底层实现

C++模板提供了对逻辑结构相同的数据对象通用行为的定义。这些模板运算对象的类型不是实际的数据类型，而是一种参数化的类型。

（1）编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板**通过具体类型**产生不同的函数；编译器会对函数模板进行**两次编译**：**在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译**。

（2）这是因为函数模板要被**实例化**后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。

### 2、简单的模板的例子

```C++
// 函数模板
#include<iostream> 
using namespace std; 

template<typename type1,typename type2>
type1 Max(type1 a,type2 b) { 
	return a > b ? a : b; 
} 
int main() { 
	cout << "Max = "<< Max(5.5,'a') << endl; 
	return 0;
}
// 输出为
// Max = 97
```

```C++
// 类模板
template <class T>
class TClass {
public:
    //...
private:
    T member;
};
```



### 3、模板类和模板函数的区别是什么？

函数模板的实例化是由编译程序在处理函数调用时**自动完成**的，而类模板的实例化必须由程序员在程序中**显式地指定**。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加，而函数模板不必。

### 4、模板类和类模板

（1）类模板是模板的定义，不是一个真实存在的类，定义中用到通用类型参数

（2）模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型替代

（3）类模板的类型参数可以由一个或多个，每个类型前面都必须加class,  如 

```C++
template <class T1, class T2> 
class someclass {......}; 
```

在定义对象时分别带入实际的类型名，如

```C++
someclass <int, double> obj;
```

（4）和实用类一样，使用类模板时要注意作用域，只能在其有效作用域内使用它定义对象

（5）模板可以有层次，一个类模板可以作为基类派生出派生类

### 5、模板特化

5.1 概述

模板特化（template specialization）不同于模板的实例化，模板参数在某种特定类型下的具体实现称为模板特化。模板特化有时也称之为模板的具体化，分别有函数模板特化和类模板特化。

5.2 函数模板特化

函数模板特化指函数模板在模板参数为特定类型下的特定实现。查看以下示例：

```C++
#include <iostream>
using namespace std;

template<typename T> T Max(T t1,T t2) {
	return (t1 > t2) ? t1 : t2;
}
typedef const char* CCP;
template<> CCP Max<CCP>(CCP s1, CCP s2) {
	return (strcmp(s1 , s2) > 0) ? s1 : s2;
}

int main() {
	// 隐式调用实例：int Max<int>(int,int)
	int i = Max(10,5);
	
	// 显式调用特化版本：const char* Max<const char*>(const char*,const char*)
	const char* p = Max<const char*>("very","good");
	cout << "i:" << i << endl;
	cout << "p:" << p << endl;
}
```

结果

```C++
i:10
p:very
```

在函数模板显示特化定义（Explicit Specialization Definition）中，显示关键字 template 和一对尖括号 <>，然后是函数模板特化的定义。该定义指出了模板名、被用来特化模板的模板实参，以及函数参数表和函数体。在上面的程序中，如果不给出函数模板Max< T>在T为const char*时的特化版本，那么在比较两个字符串的大小时，比较的是字符串的起始地址的大小(默认)，而不是字符串的内容在字典序中的先后次序。

除了定义函数模板特化版本外，还可以直接给出模板函数在特定类型下的重载形式（普通函数）。**使用函数重载可以实现函数模板特化的功能，也可以避免函数模板的特定实例的失效**。例如，把上面的模板特化可以改成如下重载函数。

```C++
typedef const char* CCP;
CCP Max(CCP s1,CCP s2) {
	return (strcmp(s1,s2)>0)?s1:s2;
}
```

程序运行结果和使用函数模板特化相同。但是，**使用普通函数重载和使用模板特化还是有不同**之处，主要表现在如下两个方面：

（1）如果使用普通重载函数，那么不管是否发生实际的函数调用，都会在目标文件中生成该函数的二进制代码。

​		而如果使用模板的特化版本，除非发生函数调用，否则不会在目标文件中包含特化模板函数的二进制代码。这符合函数模板的“惰性实例化”准则。

（2）如果使用普通重载函数，那么在分离编译模式下，需要在各个源文件中包含重载函数的声明，否则在某些源文件中就会使用模板函数，而不是重载函数。

5.3 类模板特化

类模板特化类似于函数模板的特化，即类模板参数在某种特定类型下的具体实现。考察如下代码：

```C++
#include <iostream>
using namespace std;

template<typename T>class A {
	T num;
public:
	A(){
		num=T(6.6);
	}
	void print(){
		cout<<"A'num:"<<num<<endl;
	}
};

template<> class A<string> {
	string str;
public:
	A() {
		str="A' special definition ";
	}
	void print() {
		cout<<str<<endl;
	}
};

int main() {
	A<int> a1;      //显示模板实参的隐式实例化
	a1.print();
	A<string> a2;    //使用特化的类模板
	a2.print();
}
```

输出结果：

```C++
A'num:6
A' special definition
```



### 6、模板偏特化

6.1 概述

模板偏特化（Template Partitial Specialization）是模板特化的一种特殊情况，指显示指定部分模板参数而非全部模板参数，或者指定模板参数的部分特性分而非全部特性，也称为模板部分特化。与模板偏特化相对的是模板全特化，指对所有模板参数进行特化。模板全特化与模板偏特化共同组成模板特化。

模板偏特化主要分为两种，一种是指对部分模板参数进行全特化，另一种是对模板参数特性进行特化，包括将模板参数特化为指针、引用或是另外一个模板类。

6.2 函数模板偏特化

假如我们有一个 compare 函数模板，在比较数值大小时没有问题，如果传入的是数值的地址，我们需要比较两个数值的大小，而非比较传入的地址大小。此时我们需要对 compare 函数模板进行偏特化。考察如下代码：

```C++
#include <vector>
#include <iostream> 
using namespace std;

// 函数模板
template<typename T, class N> void compare(T num1, N num2) {
	cout << "standard function template" << endl;
	if(num1>num2) {
		cout << "num1:" << num1 << " > num2:" << num2 <<endl;
	} else {
		cout << "num1:" << num1 << " <= num2:" << num2 << endl;
	}
}

// 对部分模板参数进行特化
template<class N> void compare(int num1, N num2) {
	cout<< "partitial specialization" <<endl;
	if (num1>num2)
		cout << "num1:" << num1 << " > num2:" << num2 << endl;
	else
		cout << "num1:" << num1 << " <= num2:" << num2 << endl;
}

// 将模板参数特化为指针(模板参数的部分特性)
template<typename T, class N> void compare(T* num1, N* num2) {
	cout << "new partitial specialization" << endl;
	if (*num1>*num2)
		cout << "num1:" << *num1 << " > num2:" << *num2 << endl;
	else
		cout << "num1:" << *num1 << " <= num2:" << *num2 << endl;
}

// 将模板参数特化为另一个模板类
template<typename T, class N> void compare(std::vector<T>& vecLeft, std::vector<T>& vecRight) {
	cout << "to vector partitial specialization" << endl;
	if (vecLeft.size()>vecRight.size())
		cout << "vecLeft.size()" << vecLeft.size() << " > vecRight.size():" << vecRight.size() << endl;
	else
		cout << "vecLeft.size()" << vecLeft.size() << " <= vecRight.size():" << vecRight.size() << endl;
}

int main() {
	// 调用非特化版本 compare<int,int>(int num1, int num2)
	compare<int,int>(30,31);

	// 调用偏特化版本 compare<char>(int num1, char num2)
	compare(30,'1');

	int a = 30;
	char c = '1';
	// 调用偏特化版本 compare<int,char>(int* num1, char* num2)
	compare(&a, &c);

	vector<int> vecLeft{0};
	vector<int> vecRight{1,2,3};
	// 调用偏特化版本 compare<int,char>(int* num1, char* num2)
	compare<int,int>(vecLeft,vecRight);
}
```

结果为：

```C++
standard function template
num1:30 <= num2:31
partitial specialization
num1:30 <= num2:1
new partitial specialization
num1:30 <= num2:1
to vector partitial specialization
vecLeft.size()1 <= vecRight.size():3
```

6. 3 类模板偏特化

```C++
#include <vector>
#include <iostream> 
using namespace std;

// 类模板
template<typename T, class N> class TestClass {
public:
	static bool comp(T num1, N num2) {
		cout <<"standard class template"<< endl;
		return (num1<num2) ? true : false;
	}
};

// 对部分模板参数进行特化
template<class N> class TestClass<int, N> {
public:
	static bool comp(int num1, N num2) {
		cout << "partitial specialization" << endl;
		return (num1<num2) ? true : false;
	}
};

// 将模板参数特化为指针
template<typename T, class N> class TestClass<T*, N*> {
public:
	static bool comp(T* num1, N* num2) {
		cout << "new partitial specialization" << endl;
		return (*num1<*num2) ? true : false;
	}
};

// 将模板参数特化为另一个模板类
template<typename T, class N> class TestClass<vector<T>,vector<N>> {
public:
	static bool comp(const vector<T>& vecLeft, const vector<N>& vecRight) {
		cout << "to vector partitial specialization" << endl;
		return (vecLeft.size()<vecRight.size()) ? true : false;
	}
};

int main() {
	// 调用非特化版本
	cout << TestClass<char, char>::comp('0', '1') << endl;	
	
	// 调用部分模板参数特化版本
	cout << TestClass<int,char>::comp(30, '1') << endl;		

	// 调用模板参数特化为指针版本
	int a = 30;
	char c = '1';
	cout << TestClass<int*, char*>::comp(&a, &c) << endl;		

	// 调用模板参数特化为另一个模板类版本
	vector<int> vecLeft{0};
	vector<int> vecRight{1,2,3};
	cout << TestClass<vector<int>, vector<int>>::comp(vecLeft,vecRight) << endl;	
}
```

结果为

```C++
standard class template
1
partitial specialization
1
new partitial specialization
1
to vector partitial specialization
1
```

### 7、模板类调用优先级

对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类 > 偏特化类 > 主版本模板类 （越特殊优先级越高）。这样的优先级顺序对性能也是最好的。

但是模板特化并不只是为了性能优化，更多是为了让模板函数能够正常工作，最典型的例子就是 STL中的 iterator_traits。algorithm 中大多数算法通过 iterator 对象来处理数据，但是同时允许以指针代替 iterator 对象，这是为了支持 C-Style Array。如果直接操作 iterator，那么为了支持指针类型，每个算法函数都需要进行重载，因为指针没有::value_type类型。为了解决这个问题，STL 使用了 iterator_traits 对 iterator 特性进行封装，并为指针类型做了偏特化处理，**算法通过它来操作 iterator，不需要知道实际操作的是 iterator 对象还是指针。**

```C++
template<typename IteratorClass> class iterator_traits
...
template<typename ValueType> class iterator_traits<ValueType*>
...
template<typename ValueType> class iterator_traits<ValueType const*>
...
// 后面两是针对指针类型的偏特化，也是偏特化的一种常见形式。
```

对于模板偏特化在STL中的应用，见小贺14.6部分

## 1.18 元组

1、简介

tuple是一个固定大小的不同类型值的集合，是泛化的std::pair。可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。std::tuple理论上可以有无数个任意类型的成员变量，而std::pair只能是2个成员，因此在需要保存3个及以上的数据时就需要使用tuple元组了。

```C++
#include <iostream>
#include <tuple>
#include <string>
#include <vector>
using namespace std;

int main() {
	//初始化列表赋值
	tuple<int, string, double,int> tu = { 1,"asd",1.35f,5};
	tuple<char, int, double> tu1;

	//给已定义的对象赋值
	tu1 = make_tuple('a', 1, 1.2f);
	//根据元素下标获取元组数据
	cout << get<0>(tu1) << endl;
	//根据数据类型获取元组数据
	cout << get<double>(tu) << endl;
	//通过tie进行 解包 tuple的各个元素的值
	char c1;
	int  n1;
	double d1;
	tie(c1, n1, d1) = tu1;
	cout << "first element:" << c1 << endl;
	cout << "second element:" << n1 << endl;
	cout << "third element:" << d1 << endl;
	return 0;
}
```

输出为：

```C++
a
1.35
first element:a
second element:1
third element:1.2
```



2、tuple的具体操作见[C++ tuple元组的基本用法(总结)](https://www.jb51.net/article/191040.htm)



## 1.19 C++的空指针与野指针

 二者都是是指向无效内存区域(这里的无效指的是"不安全不可控")的指针，访问行为将会导致未定义行为。

1、野指针

1. 概念：指针指向的位置是不可知的（随机的，不正确的，没有限制的）

   ```C++
   int main(void) { 
    
    int* p; // 未初始化
    std::cout<< *p << std::endl; // 未初始化就被使用
    
    return 0; 
   }
   ```

2. 产生原因：

   （1）释放内存后指针未及时置为空，依然指向该内存，可能会出现非法访问的错误

   （2）创建指针的时候没有初始化

   （3）在指针变量的作用域外使用指针

3. 避免

   （1）定义指针时要进行初始化，如果没有确定的值，就让它指向NULL。因为NULL在宏定义是#define NULL(void **) 0 它代表的是零地址，零地址是不能进行任何读写操作的。

   （2）当需要给指针指向的空间进行赋值时，检查这个指针是否已经分配空间，即指针使用之前检查有效性。

   （3）对申请好的空间进行初始化，可以使用memset(p, 0, sizeof(int))将指针指向的空间都置为0。

   （4）使用完指针后要及时释放，free或delete，释放完后将指针的指向更改为NULL。

   （5）使用智能指针。

2、空指针

1. 定义悬空指针，指针最初指向的内存已经被释放了的一种指针。

   C++11 引入了 nullptr 关键字，专门用来区分空指针、0。nullptr 的类型为nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。

   ```C++
   int main(void) { 
    int * p = nullptr;
    int* p2 = new int;
    
    p = p2;
    delete p2; }
   ```

   

2. 避免

   （1）设置为nullp后再使用

   （2）使用智能指针

## 1.20 函数调用的过程

以一个代码为例分析

```C++
#include <stdio.h>

int func(int param1 ,int param2,int param3){	// step2
        int var1 = param1;			// step3
        int var2 = param2;
        int var3 = param3;

        printf("var1=%d,var2=%d,var3=%d",var1,var2,var3);	// step4
        return var1;			// step5
}

int main(int argc, char* argv[]) {
        int result = func(1,2,3);	// step1
        return 0;
}
```

在栈中变量分布是从高地址到低地址分布，EBP是指向栈底的指针，在过程调用中不变，又称为帧指针。ESP指向栈顶，程序执行时移动，ESP减小分配空间，ESP增大释放空间，ESP又称为栈指针。

**函数的调用过程:**

1.函数main执行，main各个参数从右向左逐步压入栈中，最后压入返回地址

2.执行第step1，3个参数以从左向右的顺序压入堆栈，即从param3到param1，栈内分布如下图：

![image-20220526222445271](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526222445271.png)

 3.返回地址入栈：此时的栈内分布如下：

<img src="C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526222533368.png" alt="image-20220526222533368" style="zoom:80%;" />

4.step2函数调用时，通过跳转指令进入函数后，函数地址入栈后，EBP入栈，然后把当前ESP的值给EBP，对应的汇编指令：

```assembly
push ebp
mov ebp esp
```

  此时栈顶和栈底指向同一位置，栈内分布如下：

![image-20220526222830485](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526222830485.png)

5.step3开始执行， int var1 = param1; int var2 = param2; int var3 = param3;按申明顺序依次存储。对应的汇编：

```assembly
mov 0x8(%ebp),%eax
mov %eax,-0x4(%ebp)
```

 其中将[EBP+0x8]地址里的内容赋给EAX，即把param的值赋给EAX，然后把EAX的中的值放到[EBP-4]这个地址里，即把EAX值赋给var1，完成C代码 int var1 = param1，其他变量雷同。

![image-20220526223022143](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526223022143.png)

6.step4，输出结果，step5执行 对应的汇编代码：

```assembly
mov  -0x4(%ebp),%eax
```

 最后通过eax寄存器保存函数的返回值；

7.调用执行函数完毕，局部变量var3，var2，var1一次出栈，EBP恢复原值，返回地址出栈，找到原执行地址，param1，param2，param3依次出栈，函数调用执行完毕。图略



## 1.21 内联、宏、普通函数的区别（内联和宏分别如何实现）

### 1、内联和宏的区别

（1）**宏定义不是函数**，但是使用起来像函数。预处理器用**复制宏代码**的方式代替函数的调用，**省去了函数压栈退栈过程，提高了效率**；而**内联函数本质上是一个函数**，内联函数一般用于**函数体的代码比较简单的函数**，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。

（2）宏函数是在**预编译**的时候把所有的宏名用宏体来替换，简单的说就是字符串替换；而内联函数则是在**编译**的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率

（3）宏定义是没有**类型检查**的，无论对还是错都是直接替换；而内联函数在**编译**的时候会进行类型的检查与语法判断，内联函数满足函数的性质，比如有返回值、参数列表、可以重载等

（4）宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义

```C++
// 宏定义
#define MAX(a, b) ((a) > (b) ? (a):(b))
MAX(a, "hello");  // 错误地比较int与string,没有参数的类型检查

// 内联
#include <iostream>
inline int add(int a, int b) {
    return (a + b);
}
int main(void) {
    int a;
    a = add(1, 2);
    cout << a << endl;
    return 0;
}
```

### 2、内联和函数的区别

（1）内联函数多了inline

（2）内联函数避免了程序运行时函数调用的开销

（3）普通函数在被调用时需要寻址(函数入口地址)，普通函数不需要

（4）内联函数的代码有限制，要求代码尽量简单，不能包含复杂的结构控制语句，普通函数没有这种要求

### 3、内联的使用场景与注意事项

（1）使用宏定义的地方都可以使用 inline 函数。

（2）作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。

（3）内联函数的定义一定要出现在其第一次调用之前

不宜使用内联：（不能将所有函数都写为内联）

（1）函数体代码过长将导致内存消耗代价较高；（2）函数体内出现循环，执行函数体内代码时间要比函数调用开销大

### 4、构造函数、析构函数、虚函数可否声明为内联函数

（1）**构造函数和析构函数声明为内联函数是没有意义的**

《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作。**首先**编译器会在构造和析构函数中添加额外的操作（申请、释放内存，构造、析构对象等），致使构造函数和析构函数并不像看上去的那么精简。**其次**，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。

（2）**对于虚函数，要分情况讨论**

有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？

上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当**用对象调用虚函数（此时不具有多态性）**时，就内联展开。

**综上**，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开（前提依然是函数并不复杂的情况下）。

## 1.22 new、delete和malloc、free的区别-> 深入到operator new的三种情况与malloc中brk与mmap的实现

### 1、new、delete和malloc、free的异同点

相同点：都可用于内存的动态申请和释放

不同点：

（1）前者是C++操作符，后者是C/C++语言标准库函数

（2）new自动计算要分配的空间大小，malloc需要手动计算

（3）new是类型安全的，malloc不是。

（4）new调用名为**operator new**的标准库函数分配足够空间并调用相关对象的构造函数；delete对指针所指对象运行适当的析构函数，然后通过调用名为**operator delete**的标准库函数释放该对象所用内存。后者均没有相关调用

（5）后者需要库文件支持，前者不用

（6）new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象

### 2、new和delete的实现原理

**执行new实际上执行两个过程**:1.分配未初始化的内存空间(malloc)；2.使用对象的构造函数对空间进行初始化;返回空间的首地址。

如果在第一步分配空间中出现问题，则抛出 std:bad_alloc异常，或被某个设定的异常处理函数捕获处理;如果在第二步构造对象时出现异常，则自动调用delete释放内存。

**执行delete实际上也有两个过程**∶1.使用析构函数对对象进行析构；2.回收内存空间(free)。

以上也可以看出 new和malloc的区别,new得到的是经过初始化的空间，而malloc得到的是未初始化的空间。所以**new是new一个类型，而malloc则是malloc一个字节长度的空间**。delete和free同理,delete 不仅释放空间还析构对象，delete 一个类型,free一个字节长度的空间。

![image-20220527170646973](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527170646973.png)

### 3、malloc与free的实现原理

![image-20220527170758249](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527170758249.png)

![image-20220527170812907](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527170812907.png)



### 4、既然有了malloc/free，C++中为什么还需要new/delete呢？

malloc/free和new/delete都是用来申请内存和回收内存的。

在对非基本数据类型的对象(不是int,float等基本数据类型的数据)使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给

malloc/free，所以new/delete是必不可少的。

### 5、new和malloc的区别及其各自底层实现原理

区别：

1. new是操作符,需要编译器支持；而malloc是库函数，需要头文件支持；

2.  new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

3. malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转;

   malloc的返回类型是void*即空类型指针，需要做显式的类型转换

   ```C++
   char* pStr = (char*)malloc(100*sizeof(char))
   ```

4. new可以被重载但malloc不行;

5. new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

   ```c
   char* pStr = (char*)malloc(100*sizeof(char))
   ```

6. new发生错误会抛出出bac_alloc异常，而malloc直接返回null。

malloc底层实现:

当开辟的空间小于128K时，调用brk(）函数;当开辟的空间大于128K时，调用mmap () 。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲块。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

new底层实现，new在调用构造函数的时候进行如下几个步骤：

（1）创建一个新的对象

（2）将构造函数的作用域赋值给这个新的对象（因此this指向这个新的对象）

（3）执行构造函数中的代码（为这个新对象添加属性）

（4）返回新的对象

### 6、malloc申请的内存能用delete释放吗

不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的；从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。

malloc /free的操作对象都是必须明确大小的，而且不能用在动态类上。

new 和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。

### 7、 delete p、delete [] p、allocator都有什么作用？

1、 动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；

2、 new动态数组返回的并不是数组类型，而是一个元素类型的指针；

3、 delete[]时，数组中的元素按逆序的顺序进行销毁；

4、 new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。

### 8、malloc、realloc、calloc的区别

malloc

```C++
void* malloc(unsigned int num_size);
int *p = malloc(20*sizeof(int));申请20个int类型的空间；
```

calloc

```C++
void* calloc(size_t n,size_t size);
int *p = calloc(20, sizeof(int));
```

省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；

realloc

```C++
void realloc(void *p, size_t new_size);
```

为动态分配的空间分配额外的空间用于扩充容量

### 9、C++中有几种类型的new

（1）**plain new**

就是普通的new，我们常用的new，在C++中定义如下：

```C++
void* operator new(std::size_t) throw(std::bad_alloc);
void operator delete(void *) throw();
```

因此**plain new**在空间分配失败的情况下，抛出异常**std::bad_alloc**而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
    try {
        char *p = new char[1000000000000];	// 要求分配的空间过大
        delete p;
    }
    catch (const std::bad_alloc &ex) {
        cout << ex.what() << endl;
    }
    return 0; 
}
//执行结果：bad allocation
```

（2）**nothrow new**

nothrow new在空间分配失败的情况下是不抛出异常，而是**返回NULL**，定义如下：

```C++
void* operator new(std::size_t,const std::nothrow_t&) throw();
void operator delete(void*) throw();
```

举例如下

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
    char *p = new(nothrow) char[1000000000000];
    if (p == NULL)  cout << "alloc failed" << endl;
    delete p;
    return 0; 
}
//执行结果：alloc failed
```

（3）**placement new**

这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为**它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数**。定义如下：

```C++
void* operator new(size_t,void*);
void operator delete(void*,void*);
```

使用placement new需要注意两点：

（1）palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组

（2）placement new构造起来的对象数组，要显式的**调用他们的析构函数来销毁**（析构函数并不释放对象的内存），**千万不要使用delete**，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。

```C++
#include <iostream>
#include <string>
using namespace std;

class ADT {
    int i;
    int j;
public:
    ADT() {
        i = 10;
        j = 100;
        cout << "ADT construct i = " << i << ", j = "<<j <<endl;
    }
    ~ADT(){
        cout << "ADT destruct" << endl;
    }
};
int main() {
    char *p = new(nothrow) char[sizeof(ADT) + 1];
    if (p == NULL) cout << "alloc failed" << endl;
    ADT *q = new(p) ADT; //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可
    //delete q;		    //错误!不能在此处调用delete q;
    q->ADT::~ADT();     //显示调用析构函数
    delete[] p;
    return 0; 
}
//输出结果：
// ADT construct i = 10, j = 100
// ADT destruct
```

## 1.23 **C++**从代码到可执行程序经历了什么？

一段高级语言代码经过四个阶段的处理形成可执行的目标二进制代码：

​								  预处理→编译→汇编→链接

其中文件后缀由 .c/.cpp → .i → .s → .o →可执行目标文件

![image-20220527223419918](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527223419918.png)

1、预处理

主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：

1. 删除所有的#define，展开所有的宏定义。

2. 处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。

3. 处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。

4. 删除所有的注释，“//”和“/**/”。

5. 保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。

6. 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。

2、编译

把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。

1. 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。

2. 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。

3. 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。

4. 优化：源代码级别的一个优化过程。

5. 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。

6. 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。

3、汇编

将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样) xxx.o(Windows下)、xxx.obj(Linux下)。

4、链接

将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接。



## 1.24静态链接和动态链接的区别，具体静态链接的实现

**静态链接**

函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；

更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

**动态链接**

动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；

更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

### 静态链接的实现

静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。

重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

![image-20220527225815769](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527225815769.png)

### 动态链接的实现

静态库有以下两个问题：

当静态库更新时那么整个程序都要重新进行链接；

对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：

1. 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；

2. 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

![image-20220527225914381](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527225914381.png)





 [RAII技术]([C++中的RAII技术及典型应用 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/389300115))与智能指针

用unique_ptr实现RAII

写一个模板特化函数printType<T>，当T是int输出"I am int"，其他则输出"I am others"。这个没啥好说的。

智能指针 share_ptr是否线程安全，队列是否线程安全， share_ptr构造方式 make_share(stl)   shared_ptr的具体实现

类型转换 dynamic_cast 失败返回null会抛异常吗？  隐式类型转换规则



内存分配代码找bug，修改。

继承关系的代码找bug，修改。

C++多线程并发问题

atomic是怎么实现的 

float和int分别以什么形式存储的



类的内存模型

**C++11新特性**: lambda表达式，[c++](https://www.nowcoder.com/jump/super-jump/word?word=c%2B%2B)auto关键字寻找类型的原理    nullptr与constexpr    函数闭包

左引用 右引用 移动语义/完美转发 move实现 forward()    移动构造函数（move和右值引用）  完美转发std::forwar

左值右值与移动语义，string右值，它调用的哪个构造函数

# 2. 算法与数据结构

[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)找环

TopK问题 ： 小数据范围TopK -> 快排的partation思想；大数据范围TopK -> 外[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)+归并 / 分治+哈希+堆

 [正则表达式匹配](https://www.nowcoder.com/jump/super-jump/word?word=正则表达式匹配)

正则表达式  匹配一个电话号码

快排

交换两个数的多种方法

memcpy函数实现：完美拿下

平方去重 eg. [-3,-1,0,1,2,4] -> [0,1,4,9,16]

哈希表底层的数据结构

在一定精度下的开根号函数(double类型)

给定一个数组，大小为n，里面的数字为0~n，找出丢失的那个数

[反转链表](https://www.nowcoder.com/jump/super-jump/word?word=反转链表) 自己生成[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)

哈希冲突的解决方法及各自优劣

[哈希表](https://www.nowcoder.com/jump/super-jump/word?word=哈希表)的实现原理，哈希冲突解决

稳定的排序算法

几道路径之和(回溯)

[二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)的中序遍历及其非递归实现

[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)的实现原理其应用

stl各种容器机制及其区别

map底层实现  map及其变体

vector的原理，添加元素的方式 扩容机制（扩容过程中是否是拷贝构造） 添加不调用拷贝构造方式  vector如何删除所有值为value的元素   插入元素的时间复杂度，如何计算     手撕一个vector（构造、析构等） vector底层实现 -> 深入到STL源码，重点说了扩容和emplace_back

字符串的回文子串个数（中心扩展法、马拉车优化）

avl树和[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)的区别，优劣

随机数生成存放1-n的数组，数字不可重复，写代码

相似字符串判定，写代码

实现一个无锁队列

字符串解码

力扣 272 最接近的二叉搜索树数值 

15. 力扣三数之和

一致性哈希

布隆过滤器

无重复字符的最长子串 

旋转图像

写一个判断文件相互引用的程序 （拓扑排序？）

​    a. 每个文件可引用多个文件，应该是结构体的形式

​    b. 形成一个图的形式，需要dfs和bfs

力扣142环形[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表) II

​    a. 记录节点地址判断

​    b. 快慢指针判断

组合总和 II -> 变形：考虑有负数的情况

最大子数组和 -> 为啥你做这么快 ：浙大数据结构网课第一节课讲了4种方法~





# 3. 网络&网络编程

HTTP状态码：400，401，404， 301, 302

五种IO模型，同步阻塞

多路复用

TCP粘包问题

线程池的状态，设计思路

HTTPS加密方法

非对称加密和对称加密

内存分配的策略

DDos、SYN、xss攻击

DNS以及DNS污染

socket通信基本步骤

TCP/UDP区别以及举例

TCP的可靠性保证？超时重传 流量控制 拥塞控制

输入网址之后实现了什么；键入网址的全过程 -> 从应用层到协议栈再到网卡，通过交换机路由器的网络风暴到达服务器，加上html/css的DOM树解析与渲染；  结合七层模型讲一讲网址键入的全过程 

默认网关的作用

如何知道TCP的连接数

ARP协议相关

三次握手与四次挥手，客户端和服务端的所有可能状态，linux用什么命令查看上述状态呢

异常情况 -> 大量time_wait状态的情况， time_wait出现原因，所用资源，如何解决

HTTP报文的格式以及解析过程 -> 状态机

具体描述一下主从状态机的状态切换以及是如何推动的

epoll源码

为什么选用Redis做消息队列 -> 简单易部署，并发要求低

RabbitMQ和kafka吗

IO多路复用 -> 从同步阻塞到IO多路复用的必要性

epoll优势

epoll中LT和ET模式，概念以及详细的优劣势

应用层除去HTTP之外还有什么 -> SMTP, FTP

TIME_WAIT状态的详细分析，何时出现，何处出现，为何出现，是否有弊端，如何避免 

如果没有网络连接，应该从哪些方面去排除问题 

ping的底层 

traceroute的底层

消息队列如何保证不丢消息





# 4. OS

进程与线程的区别  深入Linux内核讲copy_process()

线程切换是在什么情况下，如何实现

线程间通信 

线程会共享内存吗

协程及其如何实现，如何切换；协程执行的时机

中断与异常

Linux内核的fork实现

Linux设置后台进程

僵尸进程与孤儿进程

虚拟内存概念

程序员在写程序时需要考虑虚拟内存吗？

ping指令的实现？

traceroute指令的实现过程？

服务器端口未打开怎么通知客户端，客户端在哪一阶段发现服务器端口未打开

epoll相关：

说下ET和LT

惊群效应及其避免（等待队列只唤醒一个，但是这是内核后来的做法）

早期内核如何处理惊群效应。如果用锁的话该怎么实现呢——如果监听的事件是在文件上，那么就可以获取文件描述符上的锁，每个进程操作前应该检查其锁标记。

锁相关问题 互斥量/条件变量/自旋锁/读写锁/信号量  [c++](https://www.nowcoder.com/jump/super-jump/word?word=c%2B%2B)11的线程/锁；自旋锁与互斥锁的区别

操作系统的文件管理

32位机的寻址空间

在实际情况中文件相互引用也会造成死锁 -> 讲了链接时候的头文件引用情况

物理地址和逻辑地址之间的转换 -> 从Linux的内存管理到MMU

简介网络层模型 -> 知道Linux内协议栈的实现吗

数据在内核空间和用户空间之间的拷贝 -> 零拷贝问题（讲到CSAPP中浅显的DMA）



# 5. 数据库

InnoDB引擎

索引失效的场景

[redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)底层的数据结构

[redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)的哈希与渐进式哈希

skiplist和 [红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)性能分析

nginx负载均衡

levelDB

最左前缀原则  MySQL有哪些索引相关的规则 -> 只知道联合索引中最左前缀原则

多个任务直接有依赖关系，通过什么数据结构描述这个关系

redis

​		详细讲一讲持久化中的AOF与RDB以及各自优劣势

​		Redis采用的是什么方式呢 -> 说了两者结合->具体是如何两者结合的呢

​		跳表和[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)的比较

​		Redis缓存和数据库的一致性，延迟双删

写一个MySQL语句 -> 类似 牛客185. 部门工资前三高的所有员工

为什么选择B+树作为索引，回表是什么

索引下推









# 6. ELSE

共享内存的实现

压测工具（webbench的使用和原理）

工厂模式

单例模式

渲染管线

防止重复提交多个请求的方法

如何防止对网页的爬取（比如小说网的小说）

linux查看进程状态

linux查看进程打开的文件

一个程序能产生随机数，利用一个接口读取随机数中第K大的数，怎么实现？如果数据很多怎么实现？

怎么查看cpu占用率？

makefile /shell脚本

git  一个分支同步另一个分支的一个commit  什么命令

linux命令 把服务器的一个文件拷贝到本地

帧同步与状态同步

描述调用main函数、实例化类，调用类中的成员函数，这一系列操作中程序的执行过程。

大型文件编译的方法 -> 说了make，CMakeLists，scons

看一下muduo库：muduo库中你觉得最巧妙的设计

