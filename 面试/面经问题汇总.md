# 1.C++

## 1.1 C语言和C++的区别

**注意：一定不能单纯的认为C语言面向过程，C++面向对象。**

C++是至少四种编程范式的集合体（面向过程，面向对象，泛型编程和元编程，[函数式编程](https://www.zhihu.com/search?q=函数式编程&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1698735362})等，实际可能不止4种）。说C++是面向对象语言，是一种很瞧不起C++的说法，因为面向对象仅仅是C++的多种范式之一；在面向对象方面，C语言提供的语法支持比较薄弱，但这不表示C是面向过程的语言。用C语言写面向对象程序不仅不弱，甚至会有一些优势。世界上有很多非常重要的、大量使用面向对象技术的软件是用纯C写的。例如Linux的图形界面GNOME。

１. C++ 有**新增的语法和关键字**，语法的区别有**头⽂件的不同**和**命名空间的不同**：

C++ 允许⾃⼰定义⾃⼰的空间，C 中不可以。

关键字⽅⾯⽐如 C++ 与 C 动态管理内存的⽅式不同，C++ 中在 malloc 和 free 的基础上增加了 new和 delete。

C++ 在指针的基础上增加了引⽤的概念。

关键字例如 C++中还增加了 auto，explicit 体现显式和隐式转换上的概念要求，还有 dynamic_cast 增加类型安全⽅⾯的内容。

２. 函数⽅⾯ **C++** 中有**重载**和**虚函数**的概念：C++ ⽀持函数重载⽽ C 不⽀持，是因为 C++ 函数的名字修饰与 C 不同，C++ 函数名字的修饰会将参数加在后⾯，例如，int func(int,double)经过名字修饰之后会变成_func_int_double，⽽ C 中则会变成 _func，所以 C++ 中会⽀持不同参数调⽤不同函数。

**C++** 还有虚函数概念，⽤以实现多态。

３. **类⽅⾯**，**C** 的 **struct** 和 **C++** 的类也有很⼤不同：C++ 中的 struct 不仅可以有成员变量还可以有成员函数，⽽且对struct 增加了权限访问的概念，struct 的默认成员访问权限和默认继承权限都是 public；C++ 中除了 struct 还有class 表示类，struct 和 class 还有⼀点不同在于 class 的默认成员访问权限和默认继承权限都是 private。

４. **C++** 中增加了**模板**还重用代码，提供了更加强⼤的 **STL** 标准库。（C++可复用性高）

最后补充⼀点就是 C 是⼀种结构化的语⾔，重点在于算法和数据结构。C 程序的设计⾸先考虑的是如何通过⼀个代码，⼀个过程对输⼊进⾏运算处理输出。⽽ C++ ⾸先考虑的是如何构造⼀个对象模型，让这个模型能够契合与之对应的问题领域，这样就能通过获取对象的状态信息得到输出。

## 1.2 C++和JAVA的区别

语言特性

1. Java语言给开发人员提供了更为简洁的语法；完全面向对象，由于JVM可以安装到任何的操作系统上，所以说它的可移植性强

2. Java语言中没有指针的概念，引入了真正的数组。不同于C++中利用指针实现的“伪数组”，Java引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在C++程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题

   注：并⾮ Java 中没有指针，Java 虚拟机内部中还是⽤了指针，保证了Java 程序的安全。

3. C++也可以在其他系统运行，但是需要不同的编码，例如对一个数字，在windows下是大端存储，在unix中则为小端存储。Java只编写一次代码，到处运行：Java程序一般都是生成字节码，在JVM里面运行得到结果

4. Java用接口(Interface)技术取代C++程序中的抽象类。接口与抽象类有同样的功能，但是省却了在实现和维护上的复杂性

5. 多重继承：C++ ⽀持多重继承但 Java 不⽀持，但JAVA⽀持⼀个类继承多个接⼝，实现 C++ 中多重继承的功能，⼜避免了 C++ 的多重继承带来的不便。

6. 数据类型和类：Java 是完全⾯向对象的语⾔，所有的函数和变量必须是类的⼀部分。除了基本数据类型之外，其余

   的都作为类对象，对象将数据和⽅法结合起来，把它们封装在类中，这样每个对象都可以实现⾃⼰的特点和⾏为。

   Java 中取消了 C++ 中的 struct 和 union 。

垃圾回收

1. C++用析构函数回收垃圾，写C和C++程序时一定要注意内存的申请和释放

2. Java语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题

应用场景

1. Java在桌面程序上不如C++实用，C++可以直接编译成 .exe文件，指针是c++的优势，可以直接对内存的操作，但同时具有危险性 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）

2. Java在Web 应用上具有C++ 无可比拟的优势，具有丰富多样的框架

3. 对于底层程序的编程以及控制方面的编程，C++很灵活，因为有句柄的存在

## 1.3 C++面向对象的思想如何体现

1. 关于面向对象

![image-20220523222112755](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220523222112755.png)

2. C++中面向对象的三大特征——封装、继承与多态

![image-20220523222225560](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220523222225560.png)

（1）封装：数据和代码捆绑在一起，避免外界干扰和不确定性访问。

封装，也就是**把客观事物封装成抽象的类**，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。

（2）继承：常见的继承的方式

1. 实现继承：指使用基类的属性和方法而无需额外编码的能力

2. 接口继承：指仅使用属性和方法的名称、但是子类必须提供实现的能力

3. 可视继承：指子窗体（类）使用基窗体（类）的外观和实现代码的能力（C++里好像不怎么用）

例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法

（3）多态

同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为。

**（重载实现编译时多态，虚函数实现运行时多态）**。

多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。**简单一句话：允许将子类类型的指针赋值给父类类型的指针**

实现多态有两种方式——重写 / 覆盖（override）与 重载（overload）：

覆盖：是指子类重新定义父类的虚函数的做法。

重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。



## 1.4 内存泄漏相关问题

### 1. 定义

内存泄漏简单的说就是申请了⼀块内存空间，使⽤完毕后没有释放掉。 它的⼀般表现⽅式是程序运⾏时间越⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。

常说的内存泄漏是指**堆内存的泄漏**。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏。

（1）new和malloc申请资源使用后，没有用delete和free释放；

（2）子类继承父类时，父类析构函数不是虚函数。

（3）Windows句柄资源使用后没有释放。

[这篇文章](https://blog.csdn.net/hailong66666/article/details/122081264)解释delete的原理很好。

### 2. 如何检测

（1）⾸先可以通过观察猜测是否可能发⽣内存泄漏，Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。

（2）使⽤ 其他⼀些 /usr/bin/stat ⼯具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，⼀个可能的解释就是有个进程出现了内存泄漏。

（3）⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 valgrind 这样的⼯具来进⾏内存泄漏的检测。

**附：valgrind的原理是什么（valgrind包括很多工具，这里主要介绍工具memcheck的原理）**

1、memcheck主要检查的错误：

- 使用未初始化的内存(Use of uninitialised memory)
- 使用已经释放了的内存(Reading/writing memory after it has been free'd)
- 使用超过malloc分配的内存空间(Reading/writing off the end of malloc'd blocks)
- 对堆栈的非法访问(Reading/writing inappropriate areas on the stack)
- 申请的空间是否有释放(Memory leaks – where pointers to malloc'd blocks are lost forever)
- malloc/free/new/delete申请和释放内存的匹配(Mismatched use of malloc/new/new [] vs free/delete/delete [])
- src和dst的重叠(Overlapping src and dst pointers in memcpy() and related functions)

2、基本原理：memcheck实现了一个仿真的CPU，被监控的程序被这个仿真CPU解释执行，从而有机会在所有的内存读写指令发生的时候，检测地址的合法性和读操作的合法性。

（1）如何知道那些地址是合法的（内存已分配）？

维护一张合法地址表（Valid-address(A) bits），当前所有可以合法读写（已分配）的地址在其中有对应的表项。该表通过以下措施维护:

全局数据(data, bss section)--在程序启动的时候标记为合法地址
局部变量--监控sp(stack pointer)的变化，动态维护
动态分配的内存--截获 分配/释放 内存的调用 ：malloc, calloc, realloc, valloc, memalign, free, new, new[], delete and delete[]
系统调用--截获mmap映射的地址
其他--可以显示知会memcheck某地字段是合法的

（2）如何知道某内存是否已经被赋值？

维护一张合法值表（Valid-value (V) bits），指示对应的bit是否已经被赋值。因为虚拟CPU可以捕获所有对内存的写指令，所以这张表很容易维护。

3、局限：

-memcheck无法检测global和stack上的内存溢出，因为溢出的地方也在Valid-address (A) bits中。这是由memcheck 的工作原理决定的。

-慢，20到30倍，被虚拟CPU解释一遍，当然慢

-内存占用高，因为要维护两张表格，而这两张表的维度正比于程序的内存



### 3. 如何避免

第一：良好的编码习惯：使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉；有new就有delete，有malloc就有free，保证它们一定成对出现；一定要将基类的析构函数声明为**虚函数**；对象数组的释放一定要用

**delete []**

第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查该链表

第三：使用智能指针。

第四：一些常见的工具插件，如ccmalloc、Dmalloc、Leaky、Valgrind（Linux下的），CRT库(Windows下的)等等。

### 4. 不用delete是不是一定会出问题

如果我们new的不是对象而是内置类型，或者说对象中并不含有指向其他堆内存的指针，那么理论上来说就算不使用delete也不会造成内存泄漏。

但是我们平时还是要遵守，这是一个好的习惯，搭配起来的话就不会出现各种各样奇怪的问题，这其实是对自己好。

### 5. 访问越界，访问到什么数据

![image-20220523224651512](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220523224651512.png)

​		![image-20220523224706785](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220523224706785.png)

![image-20220523224720482](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220523224720482.png)



## 1.5 栈和堆的区别

1. 申请和管理方式

   堆中资源由程序员控制，需要⼿动 new malloc delete free 进⾏分配和回收，如果不进⾏回收的话，会造成内存泄漏的问题。

   栈资源由编译器自动管理，在需要时由编译器⾃动分配空间，在不需要时候⾃动回收空间，⼀般保存的是局部变量和函数参数等。

2. 内存管理机制

   对于堆：系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分

   配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中）

   对于栈：只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一

   下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了）

3. 空间大小

   堆：堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中

   有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大（1G ~ 4G）

   栈：栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置）

4. 碎片问题

   对于堆，频繁的new/delete会造成大量碎片，使程序效率降低

   对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（堆和栈的区别与栈和队列的区别）

5. 生长方向

   堆向上，向高地址方向增长。 

   栈向下，向低地址方向增长。

6. 分配方式

   堆都是动态分配（没有静态分配的堆） 

   栈有静态分配和动态分配：

   ​	静态分配由编译器完成（如局部变量分配）

   ​	动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。

7. 分配效率

   堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

   操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。

8. 缓存方式

   栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；

   堆则是存放在二级缓存中，速度要慢些。



## 1.6 前后＋＋的区别

![image-20220523232614706](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220523232614706.png)





## 1.7 重载、重写与隐藏

### 1.7.1 三者的区别

（1）重载 overload

重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：

```c++
class A{
 ...
 virtual int fun();
 void fun(int);
 void fun(double, double);
 static int fun(char);
 ...
}
```



（2）重写/覆盖 override

重写指的是在派生类中覆盖基类中的同名函数，**重写就是重写函数体**，**要求基类函数必须是虚函数**,且与基类的虚函数有相同的参数个数、参数类型和返回值类型相同。举个例子：

```c++
//父类
class A{
public:
 virtual int fun(int a){}
}
//子类
class B : public A{
public:
 //重写,一般加override可以确保是重写父类的函数
 virtual int fun(int a) override{}
}
```

重载与重写的区别：

​	重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系

​	重写要求参数列表相同，重载则要求参数列表不同，返回值不要求

​	重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体

(3)隐藏 hide

隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：

1-两个函数参数相同，但是基类函数不是虚函数。**和重写的区别在于基类函数是否是虚函数。**举个例

子：

```C++
//父类
class A{
public:
 void fun(int a){
 cout << "A中的fun函数" << endl;
 }
};
//子类
class B : public A{
public:
 //隐藏父类的fun函数
 void fun(int a){
 cout << "B中的fun函数" << endl;
 }
};
int main() {
 B b;
 b.fun(2); //调用的是B中的fun函数
 b.A::fun(2); //调用A中fun函数
 return 0; 
}
```

2-**两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：**

```C++
//父类
class A{
public:
 virtual void fun(int a){
 cout << "A中的fun函数" << endl;
 }
};
//子类
class B : public A{
public:
 //隐藏父类的fun函数
 virtual void fun(char* a){
 cout << "A中的fun函数" << endl;
 }
};
int main(){
 B b;
 b.fun(2); 	   	//报错，调用的是B中的fun函数，参数类型不对
 b.A::fun(2); 	//调用A中fun函数
 return 0; }
```

### 1.7.2 C++中的重载和重写如何实现

（１）重载：C++利用命名倾轧（name mangling）技术，来更改函数名，区分参数不同的同名函数。命名倾轧是在**编译**阶段完成的。

![image-20220525204426189](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220525204426189.png)

（２）重写：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。

1.用virtual关键字申明的函数叫做虚函数，虚函数肯定是类的成员函数。

2.存在虚函数的类都有一个一维的虚函数表叫做虚表，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。

3.多态性是一个接口多种实现，是面向对象的核心，分为类的多态性和函数的多态性。

4.重写用虚函数来实现，结合动态绑定。

5.纯虚函数是虚函数再加上 = 0。

6.抽象类是指包括至少一个纯虚函数的类。

7.纯虚函数：virtual void fun()=0。即抽象类必须在子类实现这个函数，即先有名称，没有内容，在派生类实现内容。



### 1.7.3 C 语言如何实现C++中重载的效果

c语言中不允许有同名函数，因为编译时函数命名是一样的，不像c++会添加参数类型和返回类型作为函数编译后的名称，进而实现重载。如果要用c语言显现函数重载，可通过以下方式来实现：

​	1.使用函数指针来实现，重载的函数不能使用同名称，只是类似的实现了函数重载功能

​	2.重载函数使用可变参数，方式如打开文件open函数

​	3.gcc有内置函数，程序使用编译函数可以实现函数重载





## 1.8 多态及其实现，静态绑定与动态绑定

### 1-多态及其实现（详见阿秀3.5 -1）

同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为。

**（重载实现编译时多态，虚函数实现运行时多态）**。

多态性是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。**简单一句话：允许将子类类型的指针赋值给父类类型的指针**

实现多态有两种方式——重写 / 覆盖（override）与 重载（overload）：

​	重写：是指子类重新定义父类的虚函数的做法。

​	重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。例如：基类是一个抽象对象——人，那教师、运动员也是人，而使用这个抽象对象既可以表示教师、也可以表示运动员。

### 2-静态绑定与动态绑定

静态类型：对象在声明时采用的类型，在编译期确定；

动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的；

静态绑定(早绑定)：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；

动态绑定(晚绑定)：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。举个例子

```C++
#include <iostream>
using namespace std;
class A {
public:
 /*virtual*/ void func() { std::cout << "A::func()\n"; }
};
class B : public A {
public:
 void func() { std::cout << "B::func()\n"; }
};
class C : public A
{
public:
 void func() { std::cout << "C::func()\n"; }
};
int main()
{
 C* pc = new C(); //pc的静态类型是它声明的类型C*，动态类型也是C*；
 B* pb = new B(); //pb的静态类型和动态类型也都是B*；
 A* pa = pc; //pa的静态类型是它声明的类型A*，动态类型是pa所指向的对象pc的类型C*；
 pa = pb; //pa的动态类型可以更改，现在它的动态类型是B*，但其静态类型仍是声明时候
的A*；
 C *pnull = NULL; //pnull的静态类型是它声明的类型C*,没有动态类型，因为它指向了NULL；
 
 pa->func(); //A::func() pa的静态类型永远都是A*，不管其指向的是哪个子类，都是直接调
用A::func()；
 pc->func(); //C::func() pc的动、静态类型都是C*，因此调用C::func()；
 pnull->func(); //C::func() 不用奇怪为什么空指针也可以调用函数，因为这在编译期就确定
了，和指针空不空没关系；
 return 0; }
```

但是如果将A类中的virtual注释掉，运行结果则是

```C++
pa->func(); //B::func() 因为有了virtual虚函数特性，pa的动态类型指向B*，因此先在B中查找，找到后直接调用；
pc->func(); //C::func() pc的动、静态类型都是C*，因此也是先在C中查找；
pnull->func(); //空指针异常，因为是func是virtual函数，因此对func的调用只能等到运行期才能确定，然后才发现pnull是空指针；
```

在上面的例子中，

(1)如果基类A中的func不是virtual函数，那么不论pa、pb、pc指向哪个子类对象，对func的调用都是在定义pa、pb、pc时的静态类型决定，早已在编译期确定了。

(2)同样的空指针也能够直接调用no-virtual函数而不报错（这也说明一定要做空指针检查啊！），因此**静态绑定不能实现多态**；

(3)如果func是虚函数，那所有的调用都要等到运行时根据其指向对象的类型才能确定，比起静态绑定自然是要有性能损失的，但是却能实现多态特性；

### 3-引用是否能实现动态绑定，为什么可以实现？

引用在创建的时候必须初始化，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。

```C++
#include <iostream>
using namespace std;
class Base {
public:
 virtual void fun() {
 	cout << "base :: fun()" << endl;
 }
};
class Son : public Base {
public:
 virtual void fun() {
 	cout << "son :: fun()" << endl;
  }
 void func() {
 	cout << "son :: not virtual function" <<endl;
 }
};
int main() {
 Son s;
 Base& b = s; // 基类类型引用绑定已经存在的Son对象，引用必须初始化
 s.fun(); //son::fun()
 b.fun(); //son :: fun()
 return 0;	
}
// 需要说明的是虚函数才具有动态绑定，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。
```



## 1.9 抽象类与纯虚函数及其作用，纯虚函数是否有函数体，是否编译

### 1-抽象类

1、定义

抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层，称带有纯虚函数的类为抽象类。

2、作用

抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。

3、特点

抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。

如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。

抽象类不能用作参数类型、函数返回类型或显示转换的类型

可以定义指向抽象类的指针和引用，指针可以指向其派生类从而实现多态

### 2-纯虚函数

1、定义

纯虚函数是一种特殊的虚函数，它是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加 =0。定义如下：

```C++
class <类名> { virtual <类型><函数名>(<参数表>)=0; … };
```

2、引入原因

 1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。

 2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。

因此在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。

纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。

3、纯虚函数与虚函数的区别

虚函数是为了实现**动态编联**产生的，目的是**通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数**（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。

纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。

![image-20220525213451081](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220525213451081.png)

4、纯虚函数是否有函数体

纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“=0”。

既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。

5、纯虚函数是否被编译

另一个问题是 early binding 和 late binding 的问题。非虚函数都是在编译期确定的，所以都是早绑定（静态绑定，编译期绑定）；虚函数理论上我们认为它是晚绑定（动态绑定，运行时绑定）的，但如果编译器能在编译阶段确定类型，这种情况下也能早绑定，例如，在构造函数和析构函数里，或者在最终派生类上直接调用虚函数等。

6、**纯虚函数能实例化吗，为什么？派生类要实现吗，为什么？**

1.纯虚函数不可以实例化，但是可以用其派生类实例化

```c++
class Base {
 public:
    virtual void fun() = 0;
};
class Derived : public Base {
 public:
    void fun() {
    	cout << "hello" << endl;
    }
};
int main() {
    Base *b = new Derived();
    b->fun();
    return 0;
}
```

2.虚函数的原理采用vtable。类中含有纯虚函数时，其vtable 不完全，有个空位。

即"纯虚函数在类的vtable表中对应的表项被赋值为0, 也就是指向一个不存在的函数。由于编译器绝对不允许有调用一个不存在的函数的可能，所以该类不能生成对象。在它的派生类中，除非重写此函数，否则也不能生成对象。” 所以纯虚函数不能实例化。

3.纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。

4.定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它"。



## 1.10 虚函数与虚函数表

**1、虚函数的实现原理**

C++中多态的表象，在基类的函数前加上 virtual 关键字，在派⽣类中重写该函数，运⾏时将会 根据对象的实际类型来调⽤相应的函数。如果对象类型是派⽣类,就调⽤派⽣类的函数；如果是基类，就调⽤基类 的函数。

 实际上,当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址。同样派⽣类 继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成⾃⼰的虚函数表。当我们定义⼀个派⽣类对象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的.。

后续如果有⼀个基类类型的指针指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。

**2、虚函数表**

虚函数表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚函数表，所以虚函数表的元素并不包括普通函数的函数指针。
虚函数表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚函数表就可以构造出来了。

附：虚函数表何时写入

![image-20220526164207302](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526164207302.png)

**3.虚函数表指针**

虚函数表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚函数表即可。同一个类的所有对象都使用同一个虚函数表。
为了指定对象的虚函数表，对象内部包含一个虚函数表的指针，来指向自己所使用的虚函数表。为了让每个包含虚函数表的类的对象都拥有一个虚函数表指针，编译器在类中添加了一个指针，*__vptr，用来指向虚函数表。这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚函数表。

**4、虚函数表指针位置**

![image-20220525215610175](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220525215610175.png)

注：上图中是在64位环境下，int与指针大小均为8

![image-20220525215629423](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220525215629423.png)

**5、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间**

虚函数表的特征：

（1）虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成

（2）虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段

（3）虚函数表存储虚函数的地址,即虚函数表的元素是指向类成员函数的指针,而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定,即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中

根据以上特征，虚函数表类似于类中静态成员变量.静态成员变量也是全局共享，大小确定，因此最有可能存在全局数据区。

由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面。

一般分为五个区域：栈区、堆区、函数区（存放函数体等二进制代码）、全局静态区、常量区

C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型的常量区；

虚函数位于代码段(.text)，也就是内存模型的代码区。

**6、哪些函数不能是虚函数**

1) 构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；

2) 内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；

3) 静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。

4) 友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。

5) 普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。



## 1.11 C++的内存分区和可执行程序的分段（内存管理） 

### 1、内存的五大分区（程序运行时，存储区如何划分）

栈：由编译器管理分配和回收，存放局部变量和函数形参。

堆（记忆位置时理解为向上堆，往上放往上增长）：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎⽚的情况。

全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。

常量存储区：存储常量，⼀般不允许修改。例如：通过#define、const定义的常量， 源代码中以指针形式定义的字符串

代码区：存放程序的⼆进制代码。

![image-20220525221022839](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220525221022839.png)

### 2、初始化为0的全局变量在哪里？

.BSS段;

.BSS段通常是指用来存放程序中**未初始化的或者初始化为0的全局变量和静态变量**的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。

### 3、可执行程序程序三段-Text段，Date段，Bss段

![image-20220526200246600](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526200246600.png)

text段在内存中被映射为只读，date段与bss段是可写的
1. text段：代码段，就是放程序代码的，编译时确定，只读
2. date段：存放在编译阶段（而非运行时）就能确定的数据，可读可写。也就是通常所说的静态存储区，赋了初值的全局变量和赋初值的静态变量存放在这个区域，常量也存在这个区域
3. bss段：已经定义但没赋初值的全局变量和静态变量存放在这个区域。
两者之间区别是：代码段，数据段，堆栈段是CPU级别的概念，五大分区属于语言级别的概念，两者是不同的概念。

### 4、可执行程序内存空间与逻辑地址空间的映射与划分

![image-20220526202458651](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526202458651.png)

1. 首先是栈区（堆栈区stack）,堆栈是由编译器自动分配释放，存放函数的参数形参和局部变量的值（auto类型），操作方式类似于数据结构中的栈。栈的申请是由系统自动分配，如在函数内部申请一个局部变量int h,同时判断所申请空间是否小于栈的剩余空间，如果小于则为其开辟空间，为程序提供内存，否则将报异常提示栈溢出。
2. 堆（heap），堆一般由程序员分配释放，若程序员不释放，程序结束可能由OS回收。它与数据结构中的堆是两回事，分配方式类似于链表，申请则是程序员自己操作使用malloc或new。申请过程比较复杂，当系统收到程序的申请时，会遍历记录空闲内存地址的链表，以求寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序，有些情况下，新申请的内存块的首地址记录本次分配的内存块的大小，这样在delete尤其是delete[]时能正确的释放内存空间。
3. 下边是全局静态存储区，全局变量与静态变量的存储是放在一块的，初始化的全局变量与静态变量存放在一块区域，未初始化的全局变量与未初始化的静态变量存放在相邻的另一块区域。
4.  文字常量区，常量字符串就是放在该部分，只读存储区，程序结束后由系统释放
5.  程序代码区，存放程序的二进制代码区。

### 5、存储类型关键字定义变量与函数作用域与生命周期

![image-20220526202859990](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526202859990.png)

1. auto变量：函数的局部变量，如果没有声明为static，函数中定义的局部变量**全部为auto类型**，auto变量包括未加static声明的局部变量和函数的形参。在函数调用时系统会给他们分配存储空间，在函数调用结束后会自动释放这些空间。属于动态存储方式。
2. static变量：用static声明的局部变量在调用结束后不会消失而保存原来的值。static局部变量定义使用后值会存储下来。所以使用static局部变量定义只需要一次赋值。静态局部变量的作用域仅限于所定义的函数，但函数结束后变量的值会保留。直到整个程序运行结束。全局变量从定义开始作用于整个文件直至程序运行结束。
3. register寄存器变量：寄存器变量可以提高c语言的执行效率，即将局部变量的值存入CPU的寄存器中。需要注意的是！！！：1.只有动态存储的变量（自动局部变量和形参）才可以作为寄存器变量来存储，局部静态变量不可以定义为寄存器变量。2.计算机的寄存器数目是有限的，所以不能定义任意多个寄存器变量。
4. extern外部变量：即全局变量的外部表现形式，是在函数外部定义的变量。全局变量的作用域为从定义开始到源文件结束。extern对该变量作外部变量声明，**扩展变量作用域**。

### 6、常见的内存错误及对策

![image-20220527161152368](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527161152368.png)

## 1.12 static

1、作用——控制变量的存储方式和可见性

**作⽤⼀：修饰局部变量**（两变一不变）：⼀般情况下，对于局部变量在程序中是存放在栈区的，并且局部的⽣命周期在包含语句块执⾏结束时便结束了。但是如果⽤ static 关键字修饰的话，该变量便会存放在静态数据区，其⽣命周期会⼀直延续到整个程序执⾏结束。但是要注意的是，虽然⽤ static 对局部变量进⾏修饰之后，其**⽣命周期以及存储空间**发⽣了变化，但其**作⽤域**并没有改变，作⽤域还是限制在其语句块。

**作⽤⼆：修饰全部变量**：对于⼀个全局变量，它既可以在本⽂件中被访问到，也可以在同⼀个⼯程中其它源⽂件被访问(添加 extern进⾏声明即可)。⽤ static 对全局变量进⾏修饰改变了其作⽤域范围，由原来的整个⼯程可⻅变成了本⽂件可⻅。

**作⽤三：修饰函数**：⽤ static 修饰函数，情况和修饰全局变量类似，也是改变了函数的作⽤域。

**作⽤四：修饰类**：如果 C++ 中对类中的某个函数⽤ static 修饰，则表示该函数属于⼀个类⽽不是属于此类的任何特定对象；如果对类中的某个变量进⾏ static 修饰，则表示该变量以及所有的对象所有，存储空间中只存在⼀个副本，可以通过 类和对象去调⽤。（补充：静态⾮常量数据成员，其只能在类外定义和初始化，在类内仅是声明⽽已。）

**作⽤五：类成员/类函数声明 static**

函数体内 static 变量的作⽤范围为该函数体，不同于 auto 变量，该变量的内存只被分配⼀次，因此其值在下次调⽤时仍维持上次的值；

在模块内的 static 全局变量可以被模块内所⽤函数访问，但不能被模块外其它函数访问； 

在模块内的 static 函数只可被这⼀模块内的其它函数调⽤，这个函数的使⽤范围被限制在声明它的模块内； 

在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有⼀份拷⻉； 

在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因⽽只能访问类的 static 成员变量；

static 类对象必须要在类外进⾏初始化，static 修饰的变量先于对象存在，所以 static 修饰的变量要在类外初始化；

由于 static 修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 this 指针，this 指针是指向本对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问⾮ static 的类成员，只能访问 static修饰的类成员；

static 成员函数不能被 virtual 修饰，static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意义；静态成员函数没有 this 指针，虚函数的实现是为每⼀个对象分配⼀个 vptr 指针，⽽ vptr 是通过 this 指针调⽤的，所以不能为 virtual；虚函数的调⽤关系，this->vptr->ctable->virtual function。

2、作用(笼统概括)

1.第一条也是最重要的一条：隐藏。（static函数，static变量均可）。当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。

2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。

3.static的第三个作用是默认初始化为0（static变量）。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。

4.static的第四个作用：同上作用5

3、static变量初始化的时机

存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。.BSS段通常是指用来存放程序中**未初始化的或者初始化为0的全局变量和静态变量**的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。

![image-20220525223000041](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220525223000041.png)

![image-20220526083217193](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526083217193.png)

![image-20220526091620229](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526091620229.png)







## 1.13 给定类，判断大小，包括空类，加入static，加入虚函数，考虑到内存对齐

1、计算原则

与类大小有关的因素：普通成员变量，[虚函数](https://so.csdn.net/so/search?q=虚函数&spm=1001.2101.3001.7020)，继承（单一继承，多重继承，重复继承，虚拟继承）

与类大小无关的因素：[静态成员](https://so.csdn.net/so/search?q=静态成员&spm=1001.2101.3001.7020)变量，静态成员函数及普通成员函数

2、空类

```C++
class Base {};
```

空类即什么都没有的类，按上面的说法，照理说大小应该是0，但是，空类的大小为1，因为空类可以实例化，实例化必然在内存中占有一个位置，因此，编译器为其优化为一个字节大小。

某个类继承自空类

```C++
class base
{
};
class derived:public base
{
 private:
    int a;
};
```

此时，derived类的大小为4，derived类的大小是自身int成员变量的大小，至于为什么没有加上父类base的大小1是因为空白基优化的问题，在空基类被继承后，子类会优化掉基类的1字节的大小，节省了空间大小，提高了运行效率

3、一般类的大小（注意内存对齐）

```c++
class base1 {
private:
    char a;
    int b;
    double c;
};
class base2 {
private:
    char a;
    double b;
    int c;
};
```

![image-20220526084205436](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526084205436.png)

4、包含普通成员函数的一般非空类

```C++
class Base {
    int val;
    char ch;
    void fun(){}
};
```

sizeof（Base）等于8。类的大小只与它的数据成员有关，与普通成员函数、构造函数、析构函数无关。

5、包含虚函数的类

```C++
class Base {
    int val;
    char ch;
    virtual void fun(){}
};
```

sizeof（Base）等于12。Base定义了一个虚函数，编译时会生成虚函数表，该类型的实例都包含一个指向虚函数表的指针，这个指向虚函数表的指针保存在实例内存中的最前面的位置，根据内存对齐的原则，Base的大小为12个字节。

6、包含静态数据成员的类别

```C++
class Base {
    int val;
    char ch;
    static int num;
};
```

sizeof（Base）等于8。因为静态数据成员保存在全局静态数据区，该类型的所有实例共享同一个静态数据成员，静态数据成员只分配一次内存。因此，Base的大小为8个字节。

7、单继承的类

```C++
class Base {
    int val;
    char ch;
};
class Derive： public Base {
    char c;
};
```

sizeof（Derive）等于12。Base的大小为8个字节，内存对齐值为4个字节，因此在Derive中相当于包含两个成员，类型分别为Base、char，根据内存对齐，对齐值为4，Derive的大小为12个字节。

8、含虚函数的单一继承 (64位，指针大小8字节)

```C++
class Base {
private:
    char a;
public:
    virtual void f();
    virtual void g();
};
class Derived:public Base {
private:
    int b;
public:
    void f();
};
class Derived1:public Base {
private:
    double b;
public:
    void g();
    virtual void h();
};
```

![image-20220526084758046](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526084758046.png)

![image-20220526085416814](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526085416814.png)

![image-20220526085502928](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526085502928.png)

9、含虚函数的多继承

```C++
class Base1 {
private:
    char a;
public:
    virtual void f();
    virtual void g1();
};
class Base2 {
private:
    int b;
public:
    virtual void f();
    virtual void g2();
};
class Base3 {
private:
    double c;
public:
    virtual void f();
    virtual void g3();
};
class Derived:public Base1, public Base2, public Base3 {
private:
    double d;
public:
    void f();
    virtual void derived_func();
};
```

![image-20220526085612901](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526085612901.png)

首先，Derived类自己的虚函数表指针与其声明继承顺序的**第一个基类**Base1的虚函数表指针合并，此外，若Derived类重写了基类中同名的虚函数，则在三个虚函数表的对应项都应该予以修改，**Derived中新添加的虚函数位于第一个虚函数表项后面，Derived中新添加的成员变量位于类的最后面**，按其声明顺序与内存对齐原则进行排列。

10、菱形继承的问题及解决方案：虚拟继承

[C++类大小详尽讲解](https://blog.csdn.net/longjialin93528/article/details/80160467?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-80160467-blog-102457472.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-80160467-blog-102457472.pc_relevant_paycolumn_v3&utm_relevant_index=1)



## 1.14 指针和引用的区别

1、二者的区别

1. 指针是一个变量（实体），存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
2. 指针可以有多级，引用只有一级
3. 指针可以为空，引用不能为NULL且在定义时必须初始化
4. 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。
5. 指针在初始化后可以改变指向，而引用在初始化之后不可再改变（变量可以被引用为多次，但引用只能作为一个变量引用）
6. sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小；在参数传递中，指针需要被解引用后才可以对对象进行操作，而直接对引用进行修改会做用到对象本身；
7. 作为参数时也不同,传指针的实质是**传值**,传递的值是指针的地址；传引⽤的实质是**传地址**,传递的是变量的地址；
8. 引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间（具体情况还要具体分析）。
9. 指针它指向⼀块内存,指针的内容是所指向的内存的地址,在编译的时候,则是将“指针变量名-指针变量的地址”添 加到符号表中,所以说,指针包含的内容是可以改变的,允许拷⻉和赋值,有 const 和⾮ const 区别,甚⾄可以为 空,sizeof 指针得到的是指针类型的⼤⼩. 
10. ⽽对于引⽤来说,它只是⼀块内存的别名,在添加到符号表的时候,是将"引⽤变量名-引⽤对象的地址"添加到符号 表中,符号表⼀经完成不能改变,所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上,后续不能更改,也不能为空,也没有 const 和⾮ const 区别.

2、在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？

1. 需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的

2. 对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小

3. 类对象作为参数传递的时候使用引用，这是C++**类对象传递的标准方式**



## 1.15 构造函数和析构函数能否定义为虚函数

1、析构函数⼀般写成虚函数（虚析构）的原因

直观的讲：是为了降低内存泄漏的可能性.

由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成**内存泄漏**。

所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。

**析构函数可以是纯虚函数**，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。

2、构造函数不能定义成虚函数的原因（但构造函数内可以调用虚函数）

i.从存储空间角度:虚函数对应一个vtale,这个表的地址是存储在对象的内存空间的。如果将构造函数设置为虚函数,就需要到vtable 中调用，可是对象还没有实例化，没有内存空间分配，如何调用。(悖论)

ii.从使用角度:虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就要初始化实例，那使用虚函数也没有实际意义。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。

iii.从实现上看，vbtl 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型(因为子类会调父类的构造函数);而且构造函数的作用是提供初始化，在对象生命期只执行一次，不是对象的动态行为，也没有太大的必要成为虚函数。

3、构造或析构函数中调用虚函数会怎样

实际上是不应该在构造函数或析构函数中调⽤虚函数的,因为这样的调⽤其实并不会带来所想要的效果. 

举例来说就是,有⼀个动物的基类,基类中定义了⼀个动物本身⾏为的虚函数 action_type(),在基类的构造函数中 调⽤了这个虚函数.

派⽣类中重写了这个虚函数,我们期望着根据对象的真实类型不同,⽽调⽤各⾃实现的虚函数,但实际上当我们创 建⼀个派⽣类对象时,⾸先会创建派⽣类的基类部分,执⾏基类的构造函数,此时,派⽣类的⾃身部分还没有被初 始化,对于这种还没有初始化的东⻄,C++选择当它们还不存在作为⼀种安全的⽅法. 

也就是说构造派⽣类的基类部分是,编译器会认为这就是⼀个基类类型的对象,然后调⽤基类类型中的虚函数实 现,并没有按照我们想要的⽅式进⾏.即对象在派⽣类构造函数执⾏前并不会成为⼀个派⽣类对象. 

在析构函数中也是同理,派⽣类执⾏了析构函数后,派⽣类的⾃身成员呈现未定义的状态,那么在执⾏基类的析构 函数中是不可能调⽤到派⽣类重写的⽅法的.所以说,我们不应该在构在函数或析构函数中调⽤虚函数,就算调⽤ ⼀般也不会达到我们想要的结果.



## 1.16 enable_if

1、定义

C++11中引入了std::enable_if函数，enable_if 的主要作用就是当某个 condition 成立时，enable_if可以提供某种类型。enable_if在标准库中通过结构体模板实现的，声明(原型)如下：

```C++
template< bool Condition, class T = void >
struct enable_if;
```

可能的函数实现为：

```C++
template<bool B, class T = void>
struct enable_if {};
 
template<class T>
struct enable_if<true, T> { typedef T type; };
```

由上可知，只有当第一个模板参数为true时，enable_if会包含一个type=T的公有成员，否则没有该公有成员。

头文件:

```C++
#include <type_traits>
```

2、使用场景

1. **限制模板函数的参数类型**

   在某些场景下，我们需要实现只有特定类型可以调用的模板函数。如下代码所示，通过对返回值使用std::enable_if和在模板参数中使用std::enable_if均实现了只允许整形参数调用函数的功能。

   ```C++
   // enable_if example: two ways of using enable_if
   #include <iostream>
   #include <type_traits>
   
   // 1. the return type (bool) is only valid if T is an integral type:
   template <class T>
   typename std::enable_if<std::is_integral<T>::value,bool>::type
    is_odd (T i) {return bool(i%2);}
   
   // 2. the second template argument is only valid if T is an integral type:
   template < class T, class = typename std::enable_if<std::is_integral<T>::value>::type>
   bool is_even (T i) {return !bool(i%2);}
   
   int main() {
   
       short int i = 1;  // code does not compile if type of i is not integral
   
       std::cout << std::boolalpha;
       std::cout << "i is odd: " << is_odd(i) << std::endl;
       std::cout << "i is even: " << is_even(i) << std::endl;
   
       return 0;
   }
   ```

当使用float类型参数调用函数时，程序会报错：

```C++
error: no matching function for call to 'is_odd(float&)'
```



2. 在使用模板编程时，可以利用std::enable_if的特性根据模板参数的不同特性进行不同的类型选择。

   如下所示，我们可以实现一个检测变量是否为智能指针的实现：

```C++
#include <iostream>
#include <type_traits>
#include <memory>

template <typename T>
struct is_smart_pointer_helper : public std::false_type {};

template <typename T>
struct is_smart_pointer_helper<std::shared_ptr<T> > : public std::true_type {};

template <typename T>
struct is_smart_pointer_helper<std::unique_ptr<T> > : public std::true_type {};

template <typename T>
struct is_smart_pointer_helper<std::weak_ptr<T> > : public std::true_type {};

template <typename T>
struct is_smart_pointer : public is_smart_pointer_helper<typename std::remove_cv<T>::type> {};

template <typename T>
typename std::enable_if<is_smart_pointer<T>::value, void>::type check_smart_pointer(const T& t) {
    std::cout << "is smart pointer" << std::endl;
}

template <typename T>
typename std::enable_if<!is_smart_pointer<T>::value, void>::type check_smart_pointer(const T& t) {
    std::cout << "not smart pointer" << std::endl;
}

int main() {
    int* p(new int(2));
    std::shared_ptr<int> pp(new int(2));
    std::unique_ptr<int> upp(new int(4));

    check_smart_pointer(p);
    check_smart_pointer(pp);
    check_smart_pointer(upp);

    return 0;
}
```

程序输出：

```C++
not smart pointer
is smart pointer
is smart pointer
```





## 1.17 模板是如何实现的，模板特化、模板偏特化

### 1、模板是什么，底层实现

C++模板提供了对逻辑结构相同的数据对象通用行为的定义。这些模板运算对象的类型不是实际的数据类型，而是一种参数化的类型。

（1）编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板**通过具体类型**产生不同的函数；编译器会对函数模板进行**两次编译**：**在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译**。

（2）这是因为函数模板要被**实例化**后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。

### 2、简单的模板的例子

```C++
// 函数模板
#include<iostream> 
using namespace std; 

template<typename type1,typename type2>
type1 Max(type1 a,type2 b) { 
	return a > b ? a : b; 
} 
int main() { 
	cout << "Max = "<< Max(5.5,'a') << endl; 
	return 0;
}
// 输出为
// Max = 97
```

```C++
// 类模板
template <class T>
class TClass {
public:
    //...
private:
    T member;
};
```



### 3、模板类和模板函数的区别是什么？

函数模板的实例化是由编译程序在处理函数调用时**自动完成**的，而类模板的实例化必须由程序员在程序中**显式地指定**。即函数模板允许隐式调用和显式调用而类模板只能显示调用。在使用时类模板必须加，而函数模板不必。

### 4、模板类和类模板

（1）类模板是模板的定义，不是一个真实存在的类，定义中用到通用类型参数

（2）模板类是实实在在的类定义，是类模板的实例化。类定义中参数被实际类型替代

（3）类模板的类型参数可以由一个或多个，每个类型前面都必须加class,  如 

```C++
template <class T1, class T2> 
class someclass {......}; 
```

在定义对象时分别带入实际的类型名，如

```C++
someclass <int, double> obj;
```

（4）和实用类一样，使用类模板时要注意作用域，只能在其有效作用域内使用它定义对象

（5）模板可以有层次，一个类模板可以作为基类派生出派生类

### 5、模板特化

5.1 概述

模板特化（template specialization）不同于模板的实例化，模板参数在某种特定类型下的具体实现称为模板特化。模板特化有时也称之为模板的具体化，分别有函数模板特化和类模板特化。

5.2 函数模板特化

函数模板特化指函数模板在模板参数为特定类型下的特定实现。查看以下示例：

```C++
#include <iostream>
using namespace std;

template<typename T> T Max(T t1,T t2) {
	return (t1 > t2) ? t1 : t2;
}
typedef const char* CCP;
template<> CCP Max<CCP>(CCP s1, CCP s2) {
	return (strcmp(s1 , s2) > 0) ? s1 : s2;
}

int main() {
	// 隐式调用实例：int Max<int>(int,int)
	int i = Max(10,5);
	
	// 显式调用特化版本：const char* Max<const char*>(const char*,const char*)
	const char* p = Max<const char*>("very","good");
	cout << "i:" << i << endl;
	cout << "p:" << p << endl;
}
```

结果

```C++
i:10
p:very
```

在函数模板显示特化定义（Explicit Specialization Definition）中，显示关键字 template 和一对尖括号 <>，然后是函数模板特化的定义。该定义指出了模板名、被用来特化模板的模板实参，以及函数参数表和函数体。在上面的程序中，如果不给出函数模板Max< T>在T为const char*时的特化版本，那么在比较两个字符串的大小时，比较的是字符串的起始地址的大小(默认)，而不是字符串的内容在字典序中的先后次序。

除了定义函数模板特化版本外，还可以直接给出模板函数在特定类型下的重载形式（普通函数）。**使用函数重载可以实现函数模板特化的功能，也可以避免函数模板的特定实例的失效**。例如，把上面的模板特化可以改成如下重载函数。

```C++
typedef const char* CCP;
CCP Max(CCP s1,CCP s2) {
	return (strcmp(s1,s2)>0)?s1:s2;
}
```

程序运行结果和使用函数模板特化相同。但是，**使用普通函数重载和使用模板特化还是有不同**之处，主要表现在如下两个方面：

（1）如果使用普通重载函数，那么不管是否发生实际的函数调用，都会在目标文件中生成该函数的二进制代码。

​		而如果使用模板的特化版本，除非发生函数调用，否则不会在目标文件中包含特化模板函数的二进制代码。这符合函数模板的“惰性实例化”准则。

（2）如果使用普通重载函数，那么在分离编译模式下，需要在各个源文件中包含重载函数的声明，否则在某些源文件中就会使用模板函数，而不是重载函数。

```C++
// 函数模板特化的简单例子
template<typename T> //模板函数
int compare(const T &v1,const T &v2) {
 	if(v1 > v2) return -1;
 	if(v2 > v1) return 1;
 	return 0; }
//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T
template<>
int compare(const char* const &v1,const char* const &v2) {
 	return strcmp(p1,p2);
}
```



5.3 类模板特化

类模板特化类似于函数模板的特化，即类模板参数在某种特定类型下的具体实现。考察如下代码：

```C++
#include <iostream>
using namespace std;

template<typename T>class A {
	T num;
public:
	A(){
		num=T(6.6);
	}
	void print(){
		cout<<"A'num:"<<num<<endl;
	}
};

template<> class A<string> {
	string str;
public:
	A() {
		str="A' special definition ";
	}
	void print() {
		cout<<str<<endl;
	}
};

int main() {
	A<int> a1;      //显示模板实参的隐式实例化
	a1.print();
	A<string> a2;    //使用特化的类模板
	a2.print();
}
```

输出结果：

```C++
A'num:6
A' special definition
```



### 6、模板偏特化

6.1 概述

模板偏特化（Template Partitial Specialization）是模板特化的一种特殊情况，指显示指定部分模板参数而非全部模板参数，或者指定模板参数的部分特性分而非全部特性，也称为模板部分特化。与模板偏特化相对的是模板全特化，指对所有模板参数进行特化。模板全特化与模板偏特化共同组成模板特化。

模板偏特化主要分为两种，一种是指对部分模板参数进行全特化，另一种是对模板参数特性进行特化，包括将模板参数特化为指针、引用或是另外一个模板类。

6.2 函数模板偏特化

假如我们有一个 compare 函数模板，在比较数值大小时没有问题，如果传入的是数值的地址，我们需要比较两个数值的大小，而非比较传入的地址大小。此时我们需要对 compare 函数模板进行偏特化。考察如下代码：

```C++
#include <vector>
#include <iostream> 
using namespace std;

// 函数模板
template<typename T, class N> void compare(T num1, N num2) {
	cout << "standard function template" << endl;
	if(num1>num2) {
		cout << "num1:" << num1 << " > num2:" << num2 <<endl;
	} else {
		cout << "num1:" << num1 << " <= num2:" << num2 << endl;
	}
}

// 对部分模板参数进行特化
template<class N> void compare(int num1, N num2) {
	cout<< "partitial specialization" <<endl;
	if (num1>num2)
		cout << "num1:" << num1 << " > num2:" << num2 << endl;
	else
		cout << "num1:" << num1 << " <= num2:" << num2 << endl;
}

// 将模板参数特化为指针(模板参数的部分特性)
template<typename T, class N> void compare(T* num1, N* num2) {
	cout << "new partitial specialization" << endl;
	if (*num1>*num2)
		cout << "num1:" << *num1 << " > num2:" << *num2 << endl;
	else
		cout << "num1:" << *num1 << " <= num2:" << *num2 << endl;
}

// 将模板参数特化为另一个模板类
template<typename T, class N> void compare(std::vector<T>& vecLeft, std::vector<T>& vecRight) {
	cout << "to vector partitial specialization" << endl;
	if (vecLeft.size()>vecRight.size())
		cout << "vecLeft.size()" << vecLeft.size() << " > vecRight.size():" << vecRight.size() << endl;
	else
		cout << "vecLeft.size()" << vecLeft.size() << " <= vecRight.size():" << vecRight.size() << endl;
}

int main() {
	// 调用非特化版本 compare<int,int>(int num1, int num2)
	compare<int,int>(30,31);

	// 调用偏特化版本 compare<char>(int num1, char num2)
	compare(30,'1');

	int a = 30;
	char c = '1';
	// 调用偏特化版本 compare<int,char>(int* num1, char* num2)
	compare(&a, &c);

	vector<int> vecLeft{0};
	vector<int> vecRight{1,2,3};
	// 调用偏特化版本 compare<int,char>(int* num1, char* num2)
	compare<int,int>(vecLeft,vecRight);
}
```

结果为：

```C++
standard function template
num1:30 <= num2:31
partitial specialization
num1:30 <= num2:1
new partitial specialization
num1:30 <= num2:1
to vector partitial specialization
vecLeft.size()1 <= vecRight.size():3
```

6. 3 类模板偏特化

```C++
#include <vector>
#include <iostream> 
using namespace std;

// 类模板
template<typename T, class N> class TestClass {
public:
	static bool comp(T num1, N num2) {
		cout <<"standard class template"<< endl;
		return (num1<num2) ? true : false;
	}
};

// 对部分模板参数进行特化
template<class N> class TestClass<int, N> {
public:
	static bool comp(int num1, N num2) {
		cout << "partitial specialization" << endl;
		return (num1<num2) ? true : false;
	}
};

// 将模板参数特化为指针
template<typename T, class N> class TestClass<T*, N*> {
public:
	static bool comp(T* num1, N* num2) {
		cout << "new partitial specialization" << endl;
		return (*num1<*num2) ? true : false;
	}
};

// 将模板参数特化为另一个模板类
template<typename T, class N> class TestClass<vector<T>,vector<N>> {
public:
	static bool comp(const vector<T>& vecLeft, const vector<N>& vecRight) {
		cout << "to vector partitial specialization" << endl;
		return (vecLeft.size()<vecRight.size()) ? true : false;
	}
};

int main() {
	// 调用非特化版本
	cout << TestClass<char, char>::comp('0', '1') << endl;	
	
	// 调用部分模板参数特化版本
	cout << TestClass<int,char>::comp(30, '1') << endl;		

	// 调用模板参数特化为指针版本
	int a = 30;
	char c = '1';
	cout << TestClass<int*, char*>::comp(&a, &c) << endl;		

	// 调用模板参数特化为另一个模板类版本
	vector<int> vecLeft{0};
	vector<int> vecRight{1,2,3};
	cout << TestClass<vector<int>, vector<int>>::comp(vecLeft,vecRight) << endl;	
}
```

结果为

```C++
standard class template
1
partitial specialization
1
new partitial specialization
1
to vector partitial specialization
1
```

### 7、模板类调用优先级

对主版本模板类、全特化类、偏特化类的调用优先级从高到低进行排序是：全特化类 > 偏特化类 > 主版本模板类 （越特殊优先级越高）。这样的优先级顺序对性能也是最好的。

但是模板特化并不只是为了性能优化，更多是为了让模板函数能够正常工作，最典型的例子就是 STL中的 iterator_traits。algorithm 中大多数算法通过 iterator 对象来处理数据，但是同时允许以指针代替 iterator 对象，这是为了支持 C-Style Array。如果直接操作 iterator，那么为了支持指针类型，每个算法函数都需要进行重载，因为指针没有::value_type类型。为了解决这个问题，STL 使用了 iterator_traits 对 iterator 特性进行封装，并为指针类型做了偏特化处理，**算法通过它来操作 iterator，不需要知道实际操作的是 iterator 对象还是指针。**

```C++
template<typename IteratorClass> class iterator_traits
...
template<typename ValueType> class iterator_traits<ValueType*>
...
template<typename ValueType> class iterator_traits<ValueType const*>
...
// 后面两是针对指针类型的偏特化，也是偏特化的一种常见形式。
```

对于模板偏特化在STL中的应用，见小贺14.6部分

### 8、写一个模板特化函数printType<T>，当T是int输出"I am int"，其他则输出"I am others"。

```C++
// 使用模板
template<typename T> void printType(const T& a){
    if(typeid(a) == typeid(int)) {
        std::cout << "i am int" << std::endl;
    } else {
        std::cout << "i am others" << std::endl;
    }
}

int main(){
    printType(1);
    printType(1.0);
}
```

```C++
// 使用模板特化
template<typename T> void printType(const T& a){
    if(typeid(a) == typeid(int)) {
        std::cout << "i am int" << std::endl;
    } else {
        std::cout << "i am others" << std::endl;
    }
}
template<>


int main(){
    printType(1);
    printType(1.0);
}
```





## 1.18 元组

1、简介

tuple是一个固定大小的不同类型值的集合，是泛化的std::pair。可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。std::tuple理论上可以有无数个任意类型的成员变量，而std::pair只能是2个成员，因此在需要保存3个及以上的数据时就需要使用tuple元组了。

```C++
#include <iostream>
#include <tuple>
#include <string>
#include <vector>
using namespace std;

int main() {
	//初始化列表赋值
	tuple<int, string, double,int> tu = { 1,"asd",1.35f,5};
	tuple<char, int, double> tu1;

	//给已定义的对象赋值
	tu1 = make_tuple('a', 1, 1.2f);
	//根据元素下标获取元组数据
	cout << get<0>(tu1) << endl;
	//根据数据类型获取元组数据
	cout << get<double>(tu) << endl;
	//通过tie进行 解包 tuple的各个元素的值
	char c1;
	int  n1;
	double d1;
	tie(c1, n1, d1) = tu1;
	cout << "first element:" << c1 << endl;
	cout << "second element:" << n1 << endl;
	cout << "third element:" << d1 << endl;
	return 0;
}
```

输出为：

```C++
a
1.35
first element:a
second element:1
third element:1.2
```



2、tuple的具体操作见[C++ tuple元组的基本用法(总结)](https://www.jb51.net/article/191040.htm)



## 1.19 C++的空指针与野指针

 二者都是是指向无效内存区域(这里的无效指的是"不安全不可控")的指针，访问行为将会导致未定义行为。

1、野指针

1. 概念：指针指向的位置是不可知的（随机的，不正确的，没有限制的）

   ```C++
   int main(void) { 
    
    int* p; // 未初始化
    std::cout<< *p << std::endl; // 未初始化就被使用
    
    return 0; 
   }
   ```

2. 产生原因：

   （1）释放内存后指针未及时置为空，依然指向该内存，可能会出现非法访问的错误

   （2）创建指针的时候没有初始化

   （3）在指针变量的作用域外使用指针

3. 避免

   （1）定义指针时要进行初始化，如果没有确定的值，就让它指向NULL。因为NULL在宏定义是#define NULL(void **) 0 它代表的是零地址，零地址是不能进行任何读写操作的。

   （2）当需要给指针指向的空间进行赋值时，检查这个指针是否已经分配空间，即指针使用之前检查有效性。

   （3）对申请好的空间进行初始化，可以使用memset(p, 0, sizeof(int))将指针指向的空间都置为0。

   （4）使用完指针后要及时释放，free或delete，释放完后将指针的指向更改为NULL。

   （5）使用智能指针。

2、空指针

1. 定义悬空指针，指针最初指向的内存已经被释放了的一种指针。

   C++11 引入了 nullptr 关键字，专门用来区分空指针、0。nullptr 的类型为nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。

   ```C++
   int main(void) { 
    int * p = nullptr;
    int* p2 = new int;
    
    p = p2;
    delete p2; }
   ```

   

2. 避免

   （1）设置为nullp后再使用

   （2）使用智能指针

## 1.20 函数调用的过程

以一个代码为例分析

```C++
#include <stdio.h>

int func(int param1 ,int param2,int param3){	// step2
        int var1 = param1;			// step3
        int var2 = param2;
        int var3 = param3;

        printf("var1=%d,var2=%d,var3=%d",var1,var2,var3);	// step4
        return var1;			// step5
}

int main(int argc, char* argv[]) {
        int result = func(1,2,3);	// step1
        return 0;
}
```

在栈中变量分布是从高地址到低地址分布，EBP是指向栈底的指针，在过程调用中不变，又称为帧指针。ESP指向栈顶，程序执行时移动，ESP减小分配空间，ESP增大释放空间，ESP又称为栈指针。

**函数的调用过程:**

1.函数main执行，main各个参数从右向左逐步压入栈中，最后压入返回地址

2.执行第step1，3个参数以从左向右的顺序压入堆栈，即从param3到param1，栈内分布如下图：

![image-20220526222445271](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526222445271.png)

 3.返回地址入栈：此时的栈内分布如下：

<img src="C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526222533368.png" alt="image-20220526222533368" style="zoom:80%;" />

4.step2函数调用时，通过跳转指令进入函数后，函数地址入栈后，EBP入栈，然后把当前ESP的值给EBP，对应的汇编指令：

```assembly
push ebp
mov ebp esp
```

  此时栈顶和栈底指向同一位置，栈内分布如下：

![image-20220526222830485](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526222830485.png)

5.step3开始执行， int var1 = param1; int var2 = param2; int var3 = param3;按申明顺序依次存储。对应的汇编：

```assembly
mov 0x8(%ebp),%eax
mov %eax,-0x4(%ebp)
```

 其中将[EBP+0x8]地址里的内容赋给EAX，即把param的值赋给EAX，然后把EAX的中的值放到[EBP-4]这个地址里，即把EAX值赋给var1，完成C代码 int var1 = param1，其他变量雷同。

![image-20220526223022143](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220526223022143.png)

6.step4，输出结果，step5执行 对应的汇编代码：

```assembly
mov  -0x4(%ebp),%eax
```

 最后通过eax寄存器保存函数的返回值；

7.调用执行函数完毕，局部变量var3，var2，var1一次出栈，EBP恢复原值，返回地址出栈，找到原执行地址，param1，param2，param3依次出栈，函数调用执行完毕。图略



## 1.21 内联、宏、普通函数的区别（内联和宏分别如何实现）

### 1、内联和宏的区别

（1）**宏定义不是函数**，但是使用起来像函数。预处理器用**复制宏代码**的方式代替函数的调用，**省去了函数压栈退栈过程，提高了效率**；而**内联函数本质上是一个函数**，内联函数一般用于**函数体的代码比较简单的函数**，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。

（2）宏函数是在**预编译**的时候把所有的宏名用宏体来替换，简单的说就是字符串替换；而内联函数则是在**编译**的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率

（3）宏定义是没有**类型检查**的，无论对还是错都是直接替换；而内联函数在**编译**的时候会进行类型的检查与语法判断，内联函数满足函数的性质，比如有返回值、参数列表、可以重载等

（4）宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义

```C++
// 宏定义
#define MAX(a, b) ((a) > (b) ? (a):(b))
MAX(a, "hello");  // 错误地比较int与string,没有参数的类型检查

// 内联
#include <iostream>
inline int add(int a, int b) {
    return (a + b);
}
int main(void) {
    int a;
    a = add(1, 2);
    cout << a << endl;
    return 0;
}
```

### 2、内联和函数的区别

（1）内联函数多了inline

（2）内联函数避免了程序运行时函数调用的开销

（3）普通函数在被调用时需要寻址(函数入口地址)，普通函数不需要

（4）内联函数的代码有限制，要求代码尽量简单，不能包含复杂的结构控制语句，普通函数没有这种要求

### 3、内联的使用场景与注意事项

（1）使用宏定义的地方都可以使用 inline 函数。

（2）作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率。

（3）内联函数的定义一定要出现在其第一次调用之前

不宜使用内联：（不能将所有函数都写为内联）

（1）函数体代码过长将导致内存消耗代价较高；（2）函数体内出现循环，执行函数体内代码时间要比函数调用开销大

### 4、构造函数、析构函数、虚函数可否声明为内联函数

（1）**构造函数和析构函数声明为内联函数是没有意义的**

《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作。**首先**编译器会在构造和析构函数中添加额外的操作（申请、释放内存，构造、析构对象等），致使构造函数和析构函数并不像看上去的那么精简。**其次**，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。

（2）**对于虚函数，要分情况讨论**

有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？

上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当**用对象调用虚函数（此时不具有多态性）**时，就内联展开。

**综上**，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开（前提依然是函数并不复杂的情况下）。

## 1.22 new、delete和malloc、free的区别-> 深入到operator new的三种情况与malloc中brk与mmap的实现

### 1、new、delete和malloc、free的异同点

相同点：都可用于内存的动态申请和释放

不同点：

（1）前者是C++操作符，后者是C/C++语言标准库函数

（2）new自动计算要分配的空间大小，malloc需要手动计算

（3）new是类型安全的，malloc不是。

（4）new调用名为**operator new**的标准库函数分配足够空间并调用相关对象的构造函数；delete对指针所指对象运行适当的析构函数，然后通过调用名为**operator delete**的标准库函数释放该对象所用内存。后者均没有相关调用

（5）后者需要库文件支持，前者不用

（6）new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象

### 2、new和delete的实现原理

**执行new实际上执行两个过程**:1.分配未初始化的内存空间(malloc)；2.使用对象的构造函数对空间进行初始化;返回空间的首地址。

如果在第一步分配空间中出现问题，则抛出 std:bad_alloc异常，或被某个设定的异常处理函数捕获处理;如果在第二步构造对象时出现异常，则自动调用delete释放内存。

**执行delete实际上也有两个过程**∶1.使用析构函数对对象进行析构；2.回收内存空间(free)。

以上也可以看出 new和malloc的区别,new得到的是经过初始化的空间，而malloc得到的是未初始化的空间。所以**new是new一个类型，而malloc则是malloc一个字节长度的空间**。delete和free同理,delete 不仅释放空间还析构对象，delete 一个类型,free一个字节长度的空间。

![image-20220527170646973](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527170646973.png)

### 3、malloc与free的实现原理

![image-20220527170758249](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527170758249.png)

![image-20220527170812907](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527170812907.png)



### 4、既然有了malloc/free，C++中为什么还需要new/delete呢？

malloc/free和new/delete都是用来申请内存和回收内存的。

在对非基本数据类型的对象(不是int,float等基本数据类型的数据)使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给

malloc/free，所以new/delete是必不可少的。

### 5、new和malloc的区别及其各自底层实现原理

区别：

1. new是操作符,需要编译器支持；而malloc是库函数，需要头文件支持；

2.  new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

3. malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转;

   malloc的返回类型是void*即空类型指针，需要做显式的类型转换

   ```C++
   char* pStr = (char*)malloc(100*sizeof(char))
   ```

4. new可以被重载但malloc不行;

5. new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

   ```c
   char* pStr = (char*)malloc(100*sizeof(char))
   ```

6. new发生错误会抛出出bac_alloc异常，而malloc直接返回null。

malloc底层实现:

当开辟的空间小于128K时，调用brk(）函数;当开辟的空间大于128K时，调用mmap () 。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲块。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

new底层实现，new在调用构造函数的时候进行如下几个步骤：

（1）创建一个新的对象

（2）将构造函数的作用域赋值给这个新的对象（因此this指向这个新的对象）

（3）执行构造函数中的代码（为这个新对象添加属性）

（4）返回新的对象

### 6、malloc申请的内存能用delete释放吗

不能，malloc /free主要为了兼容C，new和delete 完全可以取代malloc /free的；从理论上说使用malloc申请的内存是可以通过delete释放的。不过一般不这样写的。而且也不能保证每个C++的运行时都能正常。

malloc /free的操作对象都是必须明确大小的，而且不能用在动态类上。

new 和delete会自动进行类型检查和大小，malloc/free不能执行构造函数与析构函数，所以动态对象它是不行的。

### 7、 delete p、delete [] p、allocator都有什么作用？

1、 动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数，普通数组必须是一个常量整数；

2、 new动态数组返回的并不是数组类型，而是一个元素类型的指针；

3、 delete[]时，数组中的元素按逆序的顺序进行销毁；

4、 new在内存分配上面有一些局限性，new的机制是将内存分配和对象构造组合在一起，同样的，delete也是将对象析构和内存释放组合在一起的。allocator将这两部分分开进行，allocator申请一部分内存，不进行初始化对象，只有当需要的时候才进行初始化操作。

### 8、malloc、realloc、calloc的区别

malloc

```C++
void* malloc(unsigned int num_size);
int *p = malloc(20*sizeof(int));申请20个int类型的空间；
```

calloc

```C++
void* calloc(size_t n,size_t size);
int *p = calloc(20, sizeof(int));
```

省去了人为空间计算；malloc申请的空间的值是随机初始化的，calloc申请的空间的值是初始化为0的；

realloc

```C++
void realloc(void *p, size_t new_size);
```

为动态分配的空间分配额外的空间用于扩充容量

### 9、C++中有几种类型的new

（1）**plain new**

就是普通的new，我们常用的new，在C++中定义如下：

```C++
void* operator new(std::size_t) throw(std::bad_alloc);
void operator delete(void *) throw();
```

因此**plain new**在空间分配失败的情况下，抛出异常**std::bad_alloc**而不是返回NULL，因此通过判断返回值是否为NULL是徒劳的，举个例子：

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
    try {
        char *p = new char[1000000000000];	// 要求分配的空间过大
        delete p;
    }
    catch (const std::bad_alloc &ex) {
        cout << ex.what() << endl;
    }
    return 0; 
}
//执行结果：bad allocation
```

（2）**nothrow new**

nothrow new在空间分配失败的情况下是不抛出异常，而是**返回NULL**，定义如下：

```C++
void* operator new(std::size_t,const std::nothrow_t&) throw();
void operator delete(void*) throw();
```

举例如下

```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
    char *p = new(nothrow) char[1000000000000];
    if (p == NULL)  cout << "alloc failed" << endl;
    delete p;
    return 0; 
}
//执行结果：alloc failed
```

（3）**placement new**

这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为**它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数**。定义如下：

```C++
void* operator new(size_t,void*);
void operator delete(void*,void*);
```

使用placement new需要注意两点：

（1）palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组

（2）placement new构造起来的对象数组，要显式的**调用他们的析构函数来销毁**（析构函数并不释放对象的内存），**千万不要使用delete**，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。

```C++
#include <iostream>
#include <string>
using namespace std;

class ADT {
    int i;
    int j;
public:
    ADT() {
        i = 10;
        j = 100;
        cout << "ADT construct i = " << i << ", j = "<<j <<endl;
    }
    ~ADT(){
        cout << "ADT destruct" << endl;
    }
};
int main() {
    char *p = new(nothrow) char[sizeof(ADT) + 1];
    if (p == NULL) cout << "alloc failed" << endl;
    ADT *q = new(p) ADT; //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可
    //delete q;		    //错误!不能在此处调用delete q;
    q->ADT::~ADT();     //显示调用析构函数
    delete[] p;
    return 0; 
}
//输出结果：
// ADT construct i = 10, j = 100
// ADT destruct
```

## 1.23 **C++**从代码到可执行程序经历了什么？

一段高级语言代码经过四个阶段的处理形成可执行的目标二进制代码：

​								  预处理→编译→汇编→链接

其中文件后缀由 .c/.cpp → .i → .s → .o →可执行目标文件

![image-20220527223419918](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527223419918.png)

1、预处理

主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下：

1. 删除所有的#define，展开所有的宏定义。

2. 处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。

3. 处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。

4. 删除所有的注释，“//”和“/**/”。

5. 保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重复引用。

6. 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。

2、编译

把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。

1. 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。

2. 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。

3. 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。

4. 优化：源代码级别的一个优化过程。

5. 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。

6. 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。

3、汇编

将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。经汇编之后，产生目标文件(与可执行文件格式几乎一样) xxx.o(Windows下)、xxx.obj(Linux下)。

4、链接

将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接。



## 1.24静态链接和动态链接的区别，具体静态链接的实现

**静态链接**

函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。

空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本；

更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。

运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

**动态链接**

动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；

更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。

性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

### 静态链接的实现

静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：

符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。

重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。

![image-20220527225815769](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527225815769.png)

### 动态链接的实现

静态库有以下两个问题：

当静态库更新时那么整个程序都要重新进行链接；

对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：

1. 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；

2. 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

![image-20220527225914381](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220527225914381.png)



## 1.25 float和int的存储结构与运算性能

具体见[计算机中int和float的储存结构以及运算性能](https://blog.csdn.net/weixin_40026797/article/details/112427288)

几个主要结论：

1. float 在内存中占32位，第一位是符号位（sign），符号位后面 8 位是指数位（exponent），最后 23 位是尾数（mantissa）。float值的二进制表示形式如下（该表达式对应上述二进制存储结构）：

   ```C++
   sign * mantissa * 2 ^ (exponent)
   ```

   符号位sign：表示浮点数的正负，0为正，1为负；
   指数位mantissa：实际上也有正负，但没有单独的符号位，计算机中使用二进制，指数表示的也是 2 的 N 次幂，8 位指数表达的范围是 **0至255**，而实际上是**-127至128**，也就是说，**实际的指数等于指数位表示的数值减127**。
   尾数位exponent：只表示二进制的小数点后的部分，小数点前的那位被省略了，当指数位全部为0时，省略的是0，否则省略的是1

2. float无法表示的int

   ![image-20220528151635860](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220528151635860.png)

   由此也可以得出**不能被 float 准确表达的最小 int 值是2 ^ 24 + 1**。我们再将1000000000000000000000001的值加1，变成1000000000000000000000010，这样变换为指数形式可以看出尾数又变为了23位，也就是说25位的二进制整数最后一位是0才能被float准确表示，每2个数就有一个不能被准确表示（x0与x1中只有x0才能被准确表示）。如果是26位的二进制整数最后两位都是0才可以被float准确表达，每4个数就有3个不能被准确表示（00,01,10,11中只有00才能被准确表示），以此类推。

3. 运算性能

   测试二者做乘除运算的性能。此处单纯使用主线程进行运算查看运算时间的差异

   注意：不使用额外线程是因为线程有资源优先级的问题，要排除这个影响。同时，不使用数值类型强转，避免其他性能消耗影响 。最后，为了普适化，使用 10 和 3 这种除不尽的数值。

   结论：

   （1）int 乘 int 消耗时间最多，float数据做运行的速度甚至比 int 要快那么一点点，但是从整体看来，区别不大，所以在100000000000次运算下，可以说单纯的乘除运算，int 和 float 的性能几乎一样。

   （2）使用代码进行数值运算后，肯定要储存结果，那么就存在数据转换问题。可以得到结论：

   1. int 除 int 消耗性能最高；
   2. 乘除法运算中，不同类型相乘除相对比较耗时；
   3. 都使用float运算，耗时最少，性能最高；

   （3）不同类型运算依旧相对比较耗时，同时，float 类型做乘除运算都比 int 要快一些，特别是除法运算，性能更高。

4. 总结

   （1）无论在任何平台，尽量使用同类型进行运算，这样相对比较快，节省了类型转化的时间。

   （2）在高端平台（比如PC，CPU性能较强），不用特别在意 float 的乘除问题，float单纯做乘除法的运行性能差距不大，不需要特意将除法改写为乘法，反而特意改写后可能会造成多次复合运算后的精度不准确。但在低端平台（比如CPU为M4、M7等），float 的乘法明显比除法快，建议通过改写来提升效率。

   （3）在高端平台上（比如PC，CPU性能较强），float 的乘除运算速度比 int 要快，很多人潜意识都觉得 float 的使用更消耗性能，好多时候都会强转成 int，没必要，不仅运算更慢，还不精确。当然，也不是说用 float 就是最好的选择，还需要考虑到 float 无法准确表示某些 int 数值的情况。

   （4）在低端平台上（比如CPU为M4、M7等），开启FPU（浮点运算单元）时，int 和 float 做乘法性能几乎一样；关闭FPU后，int 更快，且性能差距有十几倍。无论是否开启FPU，二者做除法运算都很慢，特别 float 的除法最慢，要避免使用。

## 1.26 C++多线程并发问题  atomic是怎么实现的（[原子操作](https://zhuanlan.zhihu.com/p/340359732)） 

### 1、多进程与多线程的使用场景

频繁修改：需要频繁创建和销毁的优先使用**多线程**，因为进程消耗资源要远高于线程

计算量：需要大量计算的优先使用**多线程** 因为需要消耗大量CPU资源且切换频繁，所以多线程好一点

相关性：任务间相关性比较强的用**多线程**，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。

多分布：可能要扩展到多机分布的用**多进程**，多核分布的用**多线程**。

但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。





 [RAII技术]([C++中的RAII技术及典型应用 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/389300115))与智能指针

用unique_ptr实现RAII

智能指针 share_ptr是否线程安全，队列是否线程安全， share_ptr构造方式 make_share(stl)   shared_ptr的具体实现

类型转换 dynamic_cast 失败返回null会抛异常吗？  隐式类型转换规则



类的内存模型

**C++11新特性**: lambda表达式，[c++](https://www.nowcoder.com/jump/super-jump/word?word=c%2B%2B)auto关键字寻找类型的原理    nullptr与constexpr    函数闭包

左引用 右引用 移动语义/完美转发 move实现 forward()    移动构造函数（move和右值引用）  完美转发std::forwar

左值右值与移动语义，string右值，它调用的哪个构造函数



内存分配代码找bug并修改。继承关系的代码找bug并修改。

# 2. 算法与数据结构

[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)找环

TopK问题 ： 小数据范围TopK -> 快排的partation思想；大数据范围TopK -> 外[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)+归并 / 分治+哈希+堆

 [正则表达式匹配](https://www.nowcoder.com/jump/super-jump/word?word=正则表达式匹配)

正则表达式  匹配一个电话号码

快排

交换两个数的多种方法

memcpy函数实现：完美拿下

平方去重 eg. [-3,-1,0,1,2,4] -> [0,1,4,9,16]

哈希表底层的数据结构

在一定精度下的开根号函数(double类型)

给定一个数组，大小为n，里面的数字为0~n，找出丢失的那个数

[反转链表](https://www.nowcoder.com/jump/super-jump/word?word=反转链表) 自己生成[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)

哈希冲突的解决方法及各自优劣

[哈希表](https://www.nowcoder.com/jump/super-jump/word?word=哈希表)的实现原理，哈希冲突解决

稳定的排序算法

几道路径之和(回溯)

[二叉树](https://www.nowcoder.com/jump/super-jump/word?word=二叉树)的中序遍历及其非递归实现

[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)的实现原理其应用

stl各种容器机制及其区别

map底层实现  map及其变体

vector的原理，添加元素的方式 扩容机制（扩容过程中是否是拷贝构造） 添加不调用拷贝构造方式  vector如何删除所有值为value的元素   插入元素的时间复杂度，如何计算     手撕一个vector（构造、析构等） vector底层实现 -> 深入到STL源码，重点说了扩容和emplace_back

字符串的回文子串个数（中心扩展法、马拉车优化）

avl树和[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)的区别，优劣

随机数生成存放1-n的数组，数字不可重复，写代码

相似字符串判定，写代码

实现一个无锁队列

字符串解码

力扣 272 最接近的二叉搜索树数值 

15. 力扣三数之和

一致性哈希

布隆过滤器

无重复字符的最长子串 

旋转图像

写一个判断文件相互引用的程序 （拓扑排序？）

​    a. 每个文件可引用多个文件，应该是结构体的形式

​    b. 形成一个图的形式，需要dfs和bfs

力扣142环形[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表) II

​    a. 记录节点地址判断

​    b. 快慢指针判断

组合总和 II -> 变形：考虑有负数的情况

最大子数组和 -> 为啥你做这么快 ：浙大数据结构网课第一节课讲了4种方法~





# 3. 网络&网络编程

## 3.0 HTTP报文的格式以及解析过程 -> 状态机；具体描述一下主从状态机的状态切换以及是如何推动的

### 1、HTTP请求报文格式

![image-20220601094624530](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220601094624530.png)

![image-20220601094639890](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220601094639890.png)

### 2、HTTP响应报文格式

![image-20220601094712016](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220601094712016.png)

![image-20220601094720250](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220601094720250.png)

### 3、HTTP协议

超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求 - 响应协议，它通常运行在**TCP** 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以 ASCII 形式给出；而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。

HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。

尽管 TCP/IP 协议是互联网上最流行的应用，**HTTP 协议中，并没有规定必须使用它或它支持的层**。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。**HTTP 假定其下层协议提供可靠的传输**。因此，**任何能够提供这种保证的协议都可以被其使用**。因此也就是其在 TCP/IP 协议族使用 TCP 作为其传输层。

通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如"HTTP/1.1 200 OK"，以及返回的内容，如请求的文件、错误消息、或者其它信息。

### 4、HTTP工作原理（HTTP请求/响应的步骤或解析过程）

HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。

HTTP 协议采用了请求/响应模型。客户端向服务器发送一个**请求报文**，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

HTTP请求/响应的步骤：

1. 客户端连接到 Web 服务器

​		一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接字连接。例如，http://www.baidu.com。（URL） 

2. 发送 HTTP 请求

​		通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据 4 部分组成。

3. 服务器接受请求并返回 HTTP 响应

​		Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据 4 部分组成。

4. 释放连接 TCP 连接

​		若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 

5. 客户端浏览器解析 HTML 内容

​		客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据HTML 的语法对其进行格式化，并在浏览器窗口中显示。

![image-20220601100708759](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220601100708759.png)

### 5、基于有限状态机实现http解析

HTTP报文的解析过程比较繁琐，基于状态机的思想设计程序会一定程度降低复杂性。

原理：自己的理解:解析http这种协议,他在解析的过程中存在不同的状态, 我们在解析的时候根据解析的内存判断不同状态下不同的处理方法,通过状态的转换,实现对协议的解析。

```C++
使用状态机完成对HTTP请求的读取和分析

主状态机作用(parse_content())：读取请求行与头部行数据
状态：请求行、头部行

从状态机作用(parse_line)：读取每一行数据
状态：读取成功、失败、需要继续读取
parse_request():读取请求行，并将主状态机状态更改为头部行
parse_header():读取头部行

主状态机初始状态为请求行，循环调用parse_line，若为成功状态继续（失败退出返回失败原因）
并且判断主状态机状态
请求->parse_request()->继续循环（失败退出返回失败原因）
头部->parse_header()->成功返回好的请求结果（失败退出返回失败原因）
```

**从状态机：**

状态转移图

![image-20220601110849419](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220601110849419.png)

从状态机三种状态

- LINE_OK ,完整读取一行
- LINE_OPEN，读取的行不完整
- LINE_BAD，读取的报文有误

从状态机每次从缓冲区读取一行信息，直至读取到 \r\n 表示读取到一行，同时将 \r\n 替换为 \0\0 便于主状态机读取该行，然后再将行起始标志定位到下一行的起始位置。

**主状态机：**

状态转移图

![image-20220601111112712](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220601111112712.png)

主状态机的初始状态是CHECK_STATE_REQUESTLINE，parse_request_line()函数中解析请求行，当解析请求行成功时，解析请求行内部函数将主状态转移至下一个状态。

当请求方法为GET时，请求报文没有请求正文，也就是说解析完头部字段后该报文的解析过程就完成了。
解析请求行比较重要的一点是需要保存url，url对应客户端请求的文档。

**示例：**

```C++
STATE_MATCHINE() {
	State cur_State = type_A;
    while (cur_State != typeC) {
        Package _pack = getNewPackage();
        switch (cur_State)
        {
        case typeA:
            process_package_state_A(_pack);
            cur_State = type_B;
            break;
        case typeB:
            process_package_state_B(_pack);
            cur_State = type_C;
            break;
        }
    }
}
```

该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通过getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。



## 3.1 常见的HTTP状态码，例如400，401，404， 301, 302

所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。

状态代码的第一个数字代表当前响应的类型：

1xx消息——请求已被服务器接收，继续处理

2xx成功——请求已成功被服务器接收、理解、并接受

3xx重定向——需要后续操作才能完成这一请求

4xx请求错误——请求含有词法错误或者无法被执行

5xx服务器错误——服务器在处理某个正确请求时发生错误

![image-20220528192900258](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220528192900258.png)

### 1XX 信息

100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

### 2XX 成功

200：OK

204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。

206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

### 3XX 重定向

301 Moved Permanently ：永久性重定向

302 Found ：临时性重定向

303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。

304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。

307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

### 4XX 客户端错误

400 Bad Request ：请求报文中存在语法错误。

401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。

403 Forbidden ：请求被拒绝。

404 Not Found

### 5XX 服务器错误

500 Internal Server Error ：服务器正在执行请求时发生错误。

503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。



## 3.2 TCP粘包问题

### 1、定义

一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。

TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

### 2、原因

1、应用程序写入数据的字节大小大于套接字发送缓冲区的大小. 

2、进行MSS大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度) 

3、以太网的payload大于MTU进行IP分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。）

4、由TCP连接复用造成的粘包问题。

5、流量控制，拥塞控制也可能导致粘包。

6、接收方不及时接收缓冲区的包，造成多个包接收

7、因为TCP默认会使用Nagle算法，此算法会导致粘包问题。

​	只有上一个分组得到确认，才会发送下一个分组；

​	收集多个小分组，在一个确认到来时一起发送。

### 3、解决方案

1. 应用层发送数据时定长发送。
2. 尾部标记序列：在包尾部增加回车或者空格符等特殊字符进行分割
3. 将消息分为消息头和消息尾，头部标记分步接收。在TCP报文的头部加上表示数据长度。
4. 使用其它复杂的协议，如RTMP协议等。
5. 如果是Nagle算法问题导致的，需要结合应用场景适当关闭该算法

## 3.4 常见的协议

### 1、应用层

|   协议 |          中文名称          |    默认端口    |                       底层协议                        |
| -----: | :------------------------: | :------------: | :---------------------------------------------------: |
|   HTTP |       超文本传输协议       |       80       |                          TCP                          |
|  HTTPS |     超文本传输安全协议     |      443       |                          TCP                          |
| Telnet |    远程登陆服务标准协议    |       23       |                          TCP                          |
|    FTP |        文件传输协议        | 20传输和21连接 |                          TCP                          |
|   SMTP | 简单邮件传输协议（发送用） |       25       |                          TCP                          |
|    POP |     邮局协议（接收用）     |      110       |                          TCP                          |
|    DNS |        域名解析服务        |       53       | 服务期间进行域传输时用TCP，客户端查询DNS服务器时用UDP |
|   TFTP |      简单文本传输协议      |       21       |                          UDP                          |
|   SNMP |      简单网络管理协议      |      161       |                          UDP                          |

### 2、网络层

| 协议 |         名称         | 作用                                                         |
| :--: | :------------------: | :----------------------------------------------------------- |
|  IP  |       网际协议       | 定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择 |
| ICMP | Internet控制报文协议 | ICMP就是一个“错误侦测与回报机制”，其目的是让我们能够检测网路的连线状况，也能确保连线的准确性，是**ping**和**traceroute**的工作协议 |
| RIP  |     路由信息协议     | 使用“跳数”(即metric)来衡量到达目标的路由距离                 |
| IGMP |  Internet组管理协议  | 用于实现组播、广播等通信                                     |

### 3、数据链路层

| 协议 |       名称       | 作用                                                         |
| :--: | :--------------: | :----------------------------------------------------------- |
| ARP  |   地址解析协议   | 根据IP地址获取物理地址                                       |
| RARP | 反向地址解析协议 | 根据物理地址获取IP地址                                       |
| PPP  |    点对点协议    | 主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案 |
|      |                  |                                                              |

## 3.5 非对称加密和对称加密

### 1、对称密钥

对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。

优点：运算速度快

缺点：无法安全地将密钥传输给通信方

### 2、非对称密钥

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。

公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

**非对称密钥除了用来加密，还可以用来进行签名**。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

优点：可以更安全地将公开密钥传输给通信发送方；

缺点：运算速度慢。



## 3.6 HTTPS

### 1、定义

HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了**隧道**进行通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

### 2、HTTP的缺点

使用明文进行通信，内容可能会被窃听；不验证通信方的身份，通信方的身份有可能遭遇伪装；无法证明报文的完整性，报文有可能遭篡改。

### 3、HTTP与HTTPS的区别

1、HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

2、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

### 4、什么是SSL/TLS ？

SSL代表安全套接字层。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议。身份验证，加密Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。

SSL/TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议。

### 5、HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是如何工作保证安全的） 

因为数字签名、摘要是证书防伪非常关键的武器。 “摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后，通过发送方的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”。

SSL/TLS协议的基本思路是采用**公钥加密法**，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。具体流程如下：

（1）客户端向服务器端发起SSL连接请求；

（2）服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥

（3）客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端

（4）服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密，

（5）进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即使第三方获得数据包，也无法对其进行加密，解密和篡改。

### 6、HTTPS常用的加密方式

HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输，对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。

![image-20220528203542553](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220528203542553.png)

确保传输安全过程（其实就是rsa原理）：

1. Client给出协议版本号、一个客户端生成的**随机数**（Client random），以及客户端支持的加密方法。

2. Server确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的**随机数**（Server random）。

3. Client确认数字证书有效，然后生成一个新的**随机数**（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给Server。

4. Server使用自己的私钥，获取Client发来的随机数（Premaster secret）。

5. Client和Server根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。



## 3.7 DDos、SYN、xss、CSRF攻击

### 1、DDos攻击

客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认。

没有彻底根治的办法，除非不使用TCP

DDos 预防：

1）限制同时打开SYN半链接的数目

2）缩短SYN半链接的Time out 时间

3）关闭不必要的服务

### 2、SYN攻击

服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

```powershell
netstat -n -p TCP | grep SYN_RECV
```

常见的防御 SYN 攻击的方法有如下几种：

缩短超时（SYN Timeout）时间

增加最大半连接数

过滤网关防护

SYN cookies技术

### 3、xss攻击(低频)

跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。

如何防范XSS攻击

1）前端，服务端，同时需要字符串输入的长度限制。

2）前端，服务端，同时需要对HTML转义处理。将其中的”<”,”>”等特殊字符进行转义编码。

防 XSS 的核心是**必须对输入的数据做过滤处理**。

### 4、CSRF攻击

（1）概念

跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。

可以这么理解CSRF攻击：攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。CRSF能做的事情包括利用你的身份发邮件，发短信，进行交易转账，甚至盗取账号信息。

（2）防范：

安全框架，例如Spring Security。

token机制。在HTTP请求中进行token验证，如果请求中没有token或者token内容不正确，则认为CSRF攻击而拒绝该请求。

验证码。通常情况下，验证码能够很好的遏制CSRF攻击，但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案。

referer识别。在HTTP Header中有一个字段Referer，它记录了HTTP请求的来源地址。如果Referer是其他网站，就有可能是CSRF攻击，则拒绝该请求。但是，服务器并非都能取到Referer。很多用户出于隐私保护的考虑，限制了Referer的发送。在某些情况下，浏览器也不会发送Referer，例如HTTPS跳转到HTTP。 

1）验证请求来源地址；

2）关键操作添加验证码；

3）在请求地址添加 token 并验证。



## 3.8 DNS以及DNS污染

### 1、定义

**官方解释**：DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数字串。

通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。

**通俗的讲**，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的ip地址，比如：167.23.10.2。

### 2、工作原理

将主机域名转换为ip地址，属于应用层协议，使用53号端口。

使用UDP传输（原因：因为UDP快！UDP的DNS协议只要一个请求、一个应答就好了。而使用基于TCP的DNS协议要三次握手、发送数据以及应答、四次挥手，但是UDP协议传输内容不能超过512字节。

但是注意客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。）

过程：

总结： 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。

一、主机向本地域名服务器的查询一般都是采用**递归查询**。

二、本地域名服务器向根域名服务器的查询是**迭代查询**。

1)当用户输入域名时，浏览器先检查**自己的缓存**中是否 这个域名映射的ip地址，有解析结束。

2）若没命中，则检查**操作系统缓存**（如Windows的hosts）中有没有解析过的结果，有解析结束。

3）若无命中，则请求**本地域名服务器**解析（ LDNS）。

4）若LDNS没有命中就直接跳到**根域名服务器**请求解析。根域名服务器返回给LDNS一个 主域名服务器地址。

5） 此时LDNS再发送请求给上一步返回的gTLD（ 通用顶级域）， 接受请求的gTLD查找并返回这个域名对应的Name Server的地址

6） Name Server根据映射关系表找到目标ip，返回给LDNS

7） LDNS缓存这个域名和对应的ip， 把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中（以备下次别的用户查询时可以直接返回结果，加速访问过程），域名解析过程至此结束

### 3、DNS的负载均衡策略

当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为**同一个主机名**配置**多个IP 地址**,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的。例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。

### 4、DNS的查询方式

当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式。

**递归解析（dns服务器会代替客户端向其他的dns服务器查询）**

局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。

**迭代解析（dns服务器帮助客户端寻找相关的服务器）**

当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析。局部DNS 服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，**迭代解析只是帮你找到相关的服务器**而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。

**反向查询**：可以让dns客户端利用IP地址查询其主机名称。

### 5、DNS污染

定义：

DNS污染是指有意或无意进行的域名服务器分组，将域名指向错误的IP地址。

一般来说，在互联网上都有可信赖的网域服务器，但为减低网络上的流量压力，一般的域名服务器都会把从上游的域名服务器获得的解析记录暂存起来，待下次有其他机器要求解析域名时，可以立即提供服务。一旦有关网域的局域域名服务器的缓存受到污染，就会把网域内的计算机导引往错误的服务器或服务器的网址。

解决方案：

![image-20220529222409778](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220529222409778.png)



## 3.9 socket通信基本步骤

### 1、socket介绍

所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的**端点的抽象**。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，**套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。**

socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个**逻辑上的概念**。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制。

socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的**特殊文件**类型（Linux下一切皆文件）。本质为

内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是**管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递**。

![image-20220529225254659](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220529225254659.png)

### 2、socket通信的基本流程

![image-20220529225617691](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220529225617691.png)

### 3、TCP通信的流程

![image-20220529225742170](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220529225742170.png)

```C++
// 服务器端 （被动接受连接的角色） 
1. 创建一个用于监听的套接字 
    - 监听：监听有客户端的连接 
    - 套接字：这个套接字其实就是一个文件描述符 
2. 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息） 
    - 客户端连接服务器的时候使用的就是这个IP和端口 
3. 设置监听，监听的fd开始工作 
4. 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字 （fd） 
5. 通信 
    - 接收数据 
    - 发送数据 
6. 通信结束，断开连接
// 客户端（主动连接的角色）
1. 创建一个用于通信的套接字（fd）
2. 连接服务器，需要指定连接的服务器的 IP 和 端口
3. 连接成功了，客户端可以直接和服务器通信 
	 - 接收数据   
 	 - 发送数据
4. 通信结束，断开连接
```



## 3.10 TCP/UDP区别以及举例

### 1、TCP的特点和UDP的特点

TCP：

（1）TCP是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；

（2）每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；

（3）TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达；

（4）TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；

（5）面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

UDP：

（１）UDP是无连接的；

（２）UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；

（３）UDP是面向报文的；

（４）UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）；

（５）UDP支持一对一、一对多、多对一和多对多的交互通信；

（６）UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

### 2、二者区别

|                |            TCP            |              UDP               |
| :------------: | :-----------------------: | :----------------------------: |
|  是否面向连接  |            是             |               否               |
|    是否可靠    |            是             |               否               |
|    面向什么    |          字节流           |              报文              |
| 是否有拥塞控制 |            是             |               否               |
|    通信方式    | 每一条TCP连接只能是点到点 | 一对一、一对多、多对一和多对多 |
|    首部开销    |      大（20个字节）       |         小（８个字节）         |
|      逻辑      |     全双工的可靠信道      |           不可靠信道           |

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

7、UDP是面向报文的，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小。

TCP是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流会发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着TCP 会根据当前网络的拥塞状态来确定每个报文段的大小。

### 3、二者对应的应用层协议

TCP：

FTP：定义了文件传输协议，使用21端口.

Telnet：它是一种用于远程登陆的端口,23端口

SMTP：定义了简单邮件传送协议，服务器开放的是25号端口。

POP3：它是和SMTP对应，POP3用于接收邮件。

UDP：

DNS：用于域名解析服务，用的是53号端口

SNMP：简单网络管理协议，使用161号端口

TFTP(Trival File Transfer Protocal)：简单文件传输协议，69

### 4、TCP的封包和拆包

封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。

封包：封包就是在发送数据报的时候为每个TCP数据包加上一个报头，将数据报分为报头和报体两个部分。报头是一个固定长度的结构体，里面包含该数据报的总长度。

拆包：接收方在接收到报文后对报文中的长度信息进行截取。

### 5、如何知道TCP的连接数





## 3.11 TCP的可靠性保证？超时重传 流量控制 拥塞控制

### 第一种回答

**确认和重传**：接收方收到报文就会确认，发送方发送一段时间后没有收到确认就会重传。

**数据校验**：TCP报文首部有校验和，用于校验报文是否损坏。

**数据合理分片和排序**：tcp会按最大传输单元(MTU)合理分片，接收方会缓存未按序到达的数据，重新排序后交给应用层。而UDP：IP数据报大于1500字节，大于MTU。这个时候发送方的IP层就需要分片，把数据报分成若干片，是的每一片都小于MTU。而接收方IP层则需要进行数据报的重组。由于UDP的特性，某一片数据丢失时，接收方便无法重组数据报，导致丢弃整个UDP数据报。

**流量控制**：当接收方来不及处理发送方的数据，能通过滑动窗口，提示发送方降低发送的速率，防止包丢失。

**拥塞控制**：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。（阿秀T79四大拥塞控制算法）

### 第二种回答

建立连接（标志位）：通信前确认通信实体存在。

序号机制（序号、确认号）：确保了数据是按序、完整到达。

数据校验（校验和）：CRC校验全部数据。

超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。

窗口机制（窗口）：提供流量控制，避免过量发送。

拥塞控制：同上。

### 第三种回答

**首部校验**

这个校验机制能够确保数据传输不会出错吗？ 答案是不能。

**原因**

TCP协议中规定，TCP的首部字段中有一个字段是**校验和**，发送方将伪首部、TCP首部、TCP数据使用累加和校验的方式计算出一个数字，然后存放在首部的校验和字段里，接收者收到TCP包后重复这个过程，然后将计算出的校验和和接收到的首部中的校验和比较，如果不一致则说明数据在传输过程中出错。

这就是TCP的数据校验机制。 但是这个机制能够保证检查出一切错误吗？**显然不能**。

因为这种校验方式是**累加和**，也就是将一系列的数字（TCP协议规定的是数据中的每16个比特位数据作为一个数字）求和后取末位。 但是小学生都知道A+B=B+A，**假如在传输的过程中有前后两个16比特位的数据前后颠倒**了（至于为什么这么巧合？我不知道，也许路由器有bug？也许是宇宙中的高能粒子击中了电缆？反正这个事情的概率不为零，就有可能会发生），**那么校验和的计算结果和颠倒之前是一样的，那么接收端肯定无法检查出这是错误的数据**。

**解决方案**

传输之前先使用MD5加密数据获得**摘要，跟数据一起发送到服务端**

服务端接收之后对数据也进行MD5加密，如果加密结果和摘要一致，则认为没有问题

## 3.12 子网掩码和默认网关的作用

![image-20220530101232763](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220530101232763.png)

**子网掩码**

子网掩码不能单独存在，它必须结合IP地址一起使用。子网掩码只有一个作用，就是将**某个IP地址划分成网络地址和主机地址两部分**。子网掩码的设定必须遵循一定的规则。与IP地址相同，子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示;右边是主机位，用二进制数字“0”表示。只有通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。

子网掩码的术语是扩展的网络前缀码不是一个地址，但是可以确定一个网络层地址哪一部分是网络号，哪一部分是主机号，1的部分代表网络号，掩码为 0的部分代表主机号。**子网掩码的作用就是获取主机IP的网络地址信息，用于区别主机通信不同情况，由此选择不同路**。其中 A类地址的默认子网掩码为 255.0.0.0;B类地址的默认子网掩码为 255.255.0.0;C类地址的默认子网掩码为：255.255.255.0。

**默认网关**

（1）网关

举例说明：一个房间走到另一个房间必然要经过一扇门。同样，从一个网络向另一个网络发送信网关息，也必须经过一道“关口”，这道关口就是网关。顾名思义，**网关（Gateway）就是一个网络连接到另一个网络的“关口”。**也就是网络关卡。

网关（Gateway）又称网间连接器、协议转换器。默认网关在网络层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关的结构也和路由器类似，不同的是互连层。网关既可以用于广域网互连，也可以用于局域网互连。

（2）默认网关

默认网关也叫缺省网关，是定义计算机网络中如何将数据包转发到其他网络中的节点（类似路由器的作用），在TCP网络上可以转发数据包到其他网络，可以为网络上的TCP主机提供同远程网络上其他主机通信时所使用的默认路由。在一个典型的TCP / IP网络，节点都有一个定义的默认路由设置，配置默认网关可以在 IP 路由表中创建一个默认路径，可以在没有特定路由的情况下，明确出发送数据包的下一跳IP地址。即**一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。**

现在主机使用的网关，一般指的是默认网关。 一台电脑的默认网关是不可以随随便便指定的，必须正确地指定，否则一台电脑就会将数据包发给不是网关的电脑，从而无法与其他网络的电脑通信。默认网关的设定有手动设置和自动设置两种方式。



## 3.13 ARP协议与RARP协议

### 1、ARP协议

地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址（MAC地址）的一个TCP/IP协议。

在**局域网**中，网络中实际传输的是“帧”，帧里面是有目标主机的MAC地址的。在**以太网**中，一个主机和另一个主机进行直接通信，必须要知道目标主机的MAC地址。但这个目标MAC地址是如何获得的呢？它就是通过地址解析协议获得的。所谓“地址解析”就是**主机在发送帧前将目标IP地址转换成目标MAC地址的过程**。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。

原理：

1.源主机发送信息时将包含目的主机IP地址的ARP请求以广播形式发送到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；
2.目的主机回应ARP应答消息；
3.收到返回消息后解析该IP地址和物理地址存入本机ARP缓存中并生成一个老化定时器，在老化前可以直接查arp表访问；

工作过程：

![image-20220530111217459](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220530111217459.png)

### 2、RARP协议（Reverse Address Resolution Protocol）

概括： 反向地址转换协议，网络层协议，RARP与ARP工作方式相反。 RARP使只知道自己硬件地址的主机能够知道其IP地址。RARP发出要反向解释的物理地址并希望返回其IP地址，应答包括能够提供所需信息的RARP服务器发出的IP地址。

原理：

(1)网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址。

(2)RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机。

(3)PC1收到RARP回应后，就使用得到的IP地址进行通讯。

## 3.14 结合七层模型讲一讲网址键入的全过程 

输入网址之后实现了什么；键入网址的全过程 -> 从应用层到协议栈再到网卡，通过交换机路由器的网络风暴到达服务器，加上html/css的DOM树解析与渲染；

![image-20220530152437795](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220530152437795.png)

### 1、简略版本

(1)应用层: 浏览器输入URL，浏览器要将URL解析为IP地址，解析域名就要用到DNS协议(可以扩展DNS解析过程)，DNS服务器是基于UDP的，因此会用到UDP协议。知道了IP地址，浏览器会开始构造一个HTTP请求报文，因此要用到http协议，如果采用https还会使用https协议先对http数据进行加密，随后将构建的报文传递给传输层。

(2)传输层:传输层会向服务端发起TCP连接，在建立连接前，会先进行TCP三次握手。为了方便传输，会对数据进行分割(以报文段为单位)，并标记编号，方便服务器接受时能够准确地还原报文信息。所以在传输层用到了TCP协议。

(3)网络层:网络层将来自传输层的TCP报文段打包，并加入源及目标的IP地址，因此用到了IP协议，随后根据路由表一跳一跳发送到目的地址。如果目标地址与源地址在同一个网段，则根据mac地址发送即可，因为又要使用到ARP协议查询mac地址。

(4)数据链路层:数据链路层将网络层传递的数据分成以"帧"为单位的数据包，因此用到了以太网协议。利用mac地址以及广播的形式进行数据帧的传递。

(5)物理层:物理层的任务就是透明地传送比特流。

(6)服务器接受请求，接受过程就是把以上步骤逆转过来，同时服务器返回HTTP响应报文。

(7)浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

(8)结束连接

### 2、详细版见[OSI七层模型工作过程&&输入URL浏览器的工作过程](https://www.icode9.com/content-4-711316.html)



## 3.15 三次握手与四次挥手

TCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连 接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。

TCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。

TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接（三次握手的目的就是保证通信双方互相建立了连接），采用 四次挥手来关闭一个连接。

### 1、三次握手

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。

**流程**

发生在客户端连接的时候，在T3.9的socket网络编程流程图中，当调用**connect()**时，底层会通过TCP协议进行三次握手。

![image-20220531210143834](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220531210143834.png)

![image-20220531205806588](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220531205806588.png)



![image-20220531205857542](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220531205857542.png)

### 2、为什么需要三次握手，两次握手会出现什么问题

三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

第一次握手：客户端发送网络包，服务端收到了。 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

第二次握手：服务端发包，客户端收到了。 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。

第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

**如果只是两次握手：**

如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，Server会保持这个相当于“僵尸”的连接，浪费资源。

### 3、什么是半连接队列

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立起连接，服务器会把此种状态下请求连接放在一个**队列**里，我们把这种队列称之为**半连接队列**。

当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象 (因为队列中放不下新的连接了)。

这里在补充一点关于**SYN-ACK** **重传次数**的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......

### 4、三次握手过程中可以携带数据吗

其实第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手不可以携带数据**

假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

也就是说，**第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击**。而对于第三次的话，此时客户端已经处于ESTABLISHED状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。

### 5、四次挥手

建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的**半关闭**（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

![image-20220531220434407](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220531220434407.png)

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。

**过程**

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：

第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。 即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。

第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。 即服务端收到连接释放 报 文 段 后 即 发 出 **确 认 报 文 段** （ ACK=1 ， 确 认 号 ack=u+1 ， 序 号 seq=v ） ， 服 务 端 进 入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。 即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。 即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

收到一个FIN只意味着在这一方向上没有数据流动。**客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态**。

![image-20220531212518474](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220531212518474.png)

![image-20220531213414407](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220531213414407.png)

### 6、挥手为什么需要四次

**第一种回答**

建立连接时，当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

**第二种回答**

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

### 7、 2MSL等待状态

TIME_WAIT状态也称为2MSL等待状态。每个具体TCP实现必须选择一个报文段最长报文寿命MSL（Maximum Segment Lifetime），它是**任何报文段被丢弃前在网络内的最长时间**。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。

![image-20220531220203806](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220531220203806.png)

这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。

**等待2MSL的意义**

1. **为了保证客户端发送的最后一个ACK报文段能够到达服务器**（也即保证断开连接的被动方接收到主动方的ACK信息）。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。

   假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一旦这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

2. **防止“已失效的连接请求报文段”出现在本连接中**。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

### 8、 客户端和服务端的所有可能状态

注：TCP的状态转换发生在三次握手与四次挥手的过程中，数据传输的过程中状态不会改变

![image-20220531220331096](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220531220331096.png)

![image-20220531221357628](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220531221357628.png)

```C++
// 11种状态
LISTEN：等待从任何远端TCP 和端口的连接请求。
SYN_SENT：发送完一个连接请求后等待一个匹配的连接请求。
SYN_RECEIVED：发送连接请求并且接收到匹配的连接请求以后等待连接请求确认。
ESTABLISHED：表示一个打开的连接，接收到的数据可以被投递给用户。连接的数据传输阶段的正常状态。
FIN_WAIT_1：等待远端TCP 的连接终止请求，或者等待之前发送的连接终止请求的确认。
FIN_WAIT_2：等待远端TCP 的连接终止请求。
CLOSE_WAIT：等待本地用户的连接终止请求。
CLOSING：等待远端TCP 的连接终止请求确认。
LAST_ACK：等待先前发送给远端TCP 的连接终止请求的确认（包括它字节的连接终止请求的确认）
TIME_WAIT：等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认。
    TIME_WAIT 两个存在的理由：
    1.可靠的实现tcp全双工连接的终止；
    2.允许老的重复分节在网络中消逝。
CLOSED：不在连接状态（这是为方便描述假想的状态，实际不存在）
// 使用客户端与服务器端表示
CLOSED：初始状态。
LISTEN：服务器处于监听状态。
SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。
SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。
ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后
进入此状态。
FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。
CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之
后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN
包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。
FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器
的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。
LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。
TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间
称为TIME_WAIT状态
```

```C++
// TCP三次握手建立连接的过程
1、一开始，建立连接之前服务器和客户端的状态都为CLOSED；
2、服务器创建socket后开始监听，变为LISTEN状态；
3、客户端请求建立连接，向服务器发送SYN报文，客户端的状态变味SYN_SENT；
4、服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD；
5、然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED；
6、服务器端收到客户端的ACK后变为ESTABLISHED。此时3次握手完成，连接建立！
```

```C++
// TCP四次挥手断开连接的过程
由于TCP连接是全双工的，断开连接会比建立连接麻烦一点点。
1、客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1；
2、服务器收到FIN后向客户端发送ACK，服务器的状态围边CLOSE_WAIT；
3、客户端收到ACK后就进入FIN_WAIT2状态，此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送；
4、直到发完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态；
5、客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态；
6、再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。
至此，还有一个状态没有出来：CLOSING状态。
CLOSING状态表示：
客户端发送了FIN，但是没有收到服务器的ACK，却收到了服务器的FIN，这种情况发生在服务器发送的ACK丢包的时候，因为网络传输有时会有意外。
```



### 9、linux用什么命令查看上述状态

查看TCP连接状态

```
\#netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'
```

```C++
CLOSED 没有使用这个套接字[netstat 无法显示closed状态]
LISTEN 套接字正在监听连接[调用listen后]
SYN_SENT 套接字正在试图主动建立连接[发送SYN后还没有收到ACK]
SYN_RECEIVED 正在处于连接的初始同步状态[收到对方的SYN，但还没收到自己发过去的SYN的ACK]
ESTABLISHED 连接已建立
CLOSE_WAIT 远程套接字已经关闭：正在等待关闭这个套接字[被动关闭的一方收到FIN]
FIN_WAIT_1 套接字已关闭，正在关闭连接[发送FIN，没有收到ACK也没有收到FIN]
// CLOSING 套接字已关闭，远程套接字正在关闭，暂时挂起关闭确认[在FIN_WAIT_1状态下收到被动方的FIN]
LAST_ACK 远程套接字已关闭，正在等待本地套接字的关闭确认[被动方在CLOSE_WAIT状态下发送FIN]
FIN_WAIT_2 套接字已关闭，正在等待远程套接字关闭[在FIN_WAIT_1状态下收到发过去FIN对应的ACK]
TIME_WAIT 这个套接字已经关闭，正在等待远程套接字的关闭传送[FIN、ACK、FIN、ACK都完毕，这是主动方的最后一个状态，在过了2MSL时间后变为CLOSED状态]
```

此外还有几种方法见[Linux系统下判断TCP连接状态的几种方法](https://blog.csdn.net/u010656463/article/details/110449733)



## 3.16 异常情况 -> 大量time_wait状态的情况，  time_wait出现原因，所用资源，如何解决（TIME_WAIT状态的详细分析，何时出现，何处出现，为何出现，是否有弊端，如何避免 ）

### 1、TIME_WAIT状态

tcp断开连接需要经过四次挥手的过程，这时候最后的ACK由主动关闭端发出，此时**主动关闭端状态为TIME_WAIT**。
为什么需要TIME_WAIT状态：
主动关闭的Socket端会进入TIME_WAIT状态，并且持续2MSL时间长度，MSL就是maximum segment lifetime(最大分节生命期），这是一个IP数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。

![image-20220601083336689](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220601083336689.png)

**等待2MSL的意义(TIME_WAIT产生的原因)**

1. **为了保证客户端发送的最后一个ACK报文段能够到达服务器（可靠的关闭TCP连接）**。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。

   假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一旦这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

2. **防止“已失效的连接请求报文段”出现在本连接中**。 客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

### 2、产生大量TIME_WAIT的原因

在[高并发](https://so.csdn.net/so/search?q=高并发&spm=1001.2101.3001.7020)短连接的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。主动关闭的一方在发送最后一个 ack 后就会进入TIME_WAIT 状态 停留2MSL（max segment lifetime）的时间，这个场景下，会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。

- 高并发让服务器在短时间范围内同时占用大量端口，而端口只0~65535的范围，有限
- 短连接表示“业务处理+传输数据的时间 远远小于 TIMEWAIT超时的时间”的连接。

### 3、大量TIME_WAIT的解决办法

1. 优化内核参数，让服务器能够快速回收和重用那些TIME_WAIT的资源

 	具体实现

```
编辑内核文件/etc/sysctl.conf，加入以下内容：

net.ipv4.tcp_syncookies = 1    %表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；

net.ipv4.tcp_tw_reuse = 1      %表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 1    %表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_fin_timeout      %修改系默认的 TIMEOUT 时间

执行 /sbin/sysctl -p 让参数生效：
/etc/sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP/IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。
允许将TIME-WAIT sockets重新用于新的TCP连接，同时TIME-WAIT sockets的加快回收
```

2. 改短连接为长连接

   短连接：

   - 连接->传输数据->关闭连接
   - HTTP是无状态的，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
   - 也可以这样说：短连接是指SOCKET连接后发送后接收完数据后马上断开连接。

   长连接

   - 连接->传输数据->保持连接 -> 传输数据-> 。。。->关闭连接。
   - 长连接指建立SOCKET连接后不管是否使用都保持连接，但安全性较差。

从区别上可以看出，长连接比短连接从根本上减少了关闭连接的次数，减少了TIME_WAIT状态的产生数量，在[高并发](https://so.csdn.net/so/search?q=高并发&spm=1001.2101.3001.7020)的系统中，这种方式的改动非常有效果，可以明显减少系统TIME_WAIT的数量。

### 4、[服务器保持了大量CLOSE_WAIT状态](https://blog.csdn.net/qq_35238352/article/details/106052401)

close_wait是被动关闭连接是形成的，根据TCP状态机，服务器端收到客户端发送的FIN，TCP协议栈会自动发送ACK，链接进入close_wait状态。但如果服务器端不执行socket的close()操作（即不向客户端发送FIN），状态就不能由close_wait迁移到last_ack，则系统中会存在很多close_wait状态的连接。

出现原因：

通常，CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的 CLOSE_WAIT 状态，那么就意味着被动关闭的一方没有及时发出 FIN 包，一般有如下几种可能：

- 程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。
- 响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。

解决办法：检查代码，问题可能出在server程序里面。



## 3.17 如果没有网络连接，应该从哪些方面去排除问题 

(1)首先是排除接触故障，即确保网线是可以正常使用的。然后禁用网卡后再启用，排除偶然故障。打开网络和共享中心窗口，单击窗口左上侧“更改适配器设置”右击其中的“本地连接“或”无线网络连接”，单击快捷菜单中的“禁用”命令，即可禁用所选网络。接下来重启网络，只需右击后单击启用即可。

(2)使用ipconfig查看计算机的上网参数

win+R -> cmd -> ipconfig，可以看到机器的配置信息，输入ipconfig/all,可以看到IP地址和网卡物理地址等相关网络详细信息。

(3)使用 ping本机回送地址(127.0.0.1) 命令测试网络的连通性，定位故障范围

在命令提示符窗口中输入”ping 127.0.0.1“，数据显示本机分别发送和接受了4个数据包，丢包率为零，可以判断本机网络协议工作正常，如显示”请求超时“，则表明**本机网卡的安装或TCP/IP协议有问题**，接下来就应该**检查网卡和TCP/IP协议**，卸载后重装即可。

(4)ping本机IP

在确认127.0.0.1地址能被ping通的情况下，继续使用ping命令测试本机的IP地址能否被ping通。如不能，说明本机的网卡驱动程序不正确，或者网卡与网线之间连接有故障，也有可能是本地的路由表面收到了破坏，此时应**检查本机网卡的状态是否为已连接，网络参数是否设置正确**，如果正确可是不能ping通，就应该重**新安装网卡驱动程序**。丢失率为零，可以判断网卡安装配置没有问题，工作正常。

(5)ping网关

网关地址能被ping通的话，表明本机网络连接以及正常，如果命令不成功，可能是**网关设备自身存在问题，也可能是本机上网参数设置有误，检查网络参数**。

(6)检查防火墙的策略，看是不是没有放行。



## 3.18 [ICMP协议及ping和traceroute ](https://blog.csdn.net/qq_34827674/article/details/105106807) 

### 1、IP协议的助手 —— ICMP 协议

ICMP 全称是 **Internet Control Message Protocol**，也就是**互联网控制报文协议**。

#### （1）功能

**确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。**

![image-20220602190717767](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220602190717767.png)

如上图例子，主机 A 向主机 B 发送了数据包，由于某种原因，途中的路由器 2 未能发现主机 B 的存在，这时，路由器 2 就会向主机 A 发送一个 ICMP 目标不可达数据包，说明发往主机 B 的包未能成功。

ICMP 的这种通知消息会使用 **IP** 进行发送 。

因此，从路由器 2 返回的 ICMP 包会按照往常的路由控制先经过路由器 1 再转发给主机 A 。收到该 ICMP 包的主机 A 则分解 ICMP 包的首部和数据域以后得知具体发生问题的原因。

#### （2）ICMP包头格式

![ICMP 报文](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QvJUU4JUFFJUExJUU3JUFFJTk3JUU2JTlDJUJBJUU3JUJEJTkxJUU3JUJCJTlDL3BpbmcvNS5qcGc?x-oss-process=image/format,png)

ICMP 包头的**类型**字段，大致可以分为两大类：

- 一类是用于诊断的查询消息，也就是「**查询报文类型**」
- 另一类是通知出错原因的错误消息，也就是「**差错报文类型**」

![image-20220602191044149](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220602191044149.png)

#### （3）查询报文类型

```
回送消息 —— 类型 0 和 8
回送消息用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，ping 命令就是利用这个消息实现的
```

![image-20220602191216344](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220602191216344.png)

可以向对端主机发送**回送请求**的消息（`ICMP Echo Request Message`，类型 `8`），也可以接收对端主机发回来的**回送应答**消息（`ICMP Echo Reply Message`，类型 `0`）

![image-20220602191245979](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220602191245979.png)

相比原生的 ICMP，这里多了两个字段：

1. 标识符：用以区分是哪个应用程序发 ICMP 包，比如用进程 PID 作为标识符；
2. 序号：序列号从 0 开始，每发送一次新的回送请求就会加 1， 可以用来确认网络包是否有丢失。在选项数据中，ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。

#### （4）差错报文类型

接下来，说明几个常用的 ICMP 差错报文的例子：

- 目标不可达消息 —— 类型 为 `3`
- 原点抑制消息 —— 类型 `4`
- 重定向消息 —— 类型 `5`
- 超时消息 —— 类型  11

```
目标不可达消息（Destination Unreachable Message） —— 类型为 3
```

IP 路由器无法将 IP 数据包发送给目标地址时，会给发送端主机返回一个目标不可达的 ICMP 消息，并在这个消息中显示不可达的具体原因，原因记录在 ICMP 包头的代码字段。

由此，根据 ICMP 不可达的具体消息，发送端主机也就可以了解此次发送不可达的具体原因。

6 种常见的目标不可达类型的代码：

```
0	网络不可达(Network Unreachable)
1	主机不可达(Host Unreachable)
2	协议不可达(Protocol Unreachable)
3	端口不可达(Port Unreachable)
4	需要进行分片但设置了不分片(Fragmentation needed but no frag)
```

利用送外卖的例子介绍以上几种不可达类型：

```
0	网络不可达(Network Unreachable)
```

外卖版本：

第一次送外卖时，小区里只有 A 和 B 区两栋楼，但送餐地址写的是 C 区楼，小林表示头上很多问号，压根就没这个地方。

正常版本：

IP 地址是分为网络号和主机号的，所以当路由器中的路由器表匹配不到接收方 IP 的网络号，就通过 ICMP 协议以网络不可达（Network Unreachable）的原因告知主机。

自从不再有网络分类以后，网络不可达也渐渐不再使用了。

```
1	主机不可达(Host Unreachable)
```

外卖版本：

第二次送外卖时，这次小区有 5 层楼高的 C 区楼了，找到地方了，但送餐地址写的是 C 区楼 601 号房 ，说明找不到这个房间。

正常版本：

当路由表中没有该主机的信息，或者该主机没有连接到网络，那么会通过 ICMP 协议以主机不可达（Host Unreachable）的原因告知主机。

```
2	协议不可达(Protocol Unreachable)
```

外卖版本：

第三次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，但是一开门人家是外国人说的是英语，我说的是中文！语言不通，外卖送达失败~

正常版本：

当主机使用 TCP 协议访问对端主机时，能找到对端的主机了，可是对端主机的防火墙已经禁止 TCP 协议访问，那么会通过 ICMP 协议以协议不可达的原因告知主机。

```
3	端口不可达(Port Unreachable)
```

外卖版本：

第四次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，房间里的人也是说中文的人了，但是人家说他要的不是外卖，而是快递。。。

正常版本：

当主机访问对端主机 8080 端口时，这次能找到对端主机了，防火墙也没有限制，可是发现对端主机没有进程监听 8080 端口，那么会通过 ICMP 协议以端口不可达的原因告知主机。

```
4	需要进行分片但设置了不分片(Fragmentation needed but no frag)
```

外卖版本：

第五次送外卖时，这次是个吃播博主点了 100 份外卖，但是吃播博主要求一次性要把全部外卖送达，一台电动车装不下呀，这样就没办法送达了。

正常版本：

发送端主机发送 IP 数据报时，将 IP 首部的分片禁止标志位设置为1。根据这个标志位，途中的路由器遇到超过 MTU 大小的数据包时，不会进行分片，而是直接抛弃。

随后，通过一个 ICMP 的不可达消息类型，代码为 4 的报文，告知发送端主机。

```
原点抑制消息（ICMP Source Quench Message） —— 类型 4
```

在使用低速广域线路的情况下，连接 WAN 的路由器可能会遇到网络拥堵的问题。

ICMP 原点抑制消息的目的就是为了缓和这种拥堵情况。

当路由器向低速线路发送数据时，其发送队列的缓存变为零而无法发送出去时，可以向 IP 包的源地址发送一个 ICMP 原点抑制消息。

收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况，从而增大 IP 包的传输间隔，减少网络拥堵的情况。

然而，由于这种 ICMP 可能会引起不公平的网络通信，一般不被使用。

```
重定向消息（ICMP Redirect Message） —— 类型 5
```

如果路由器发现发送端主机使用了「不是最优」的路径发送数据，那么它会返回一个 ICMP 重定向消息给这个主机。

在这个消息中包含了最合适的路由信息和源数据。这主要发生在路由器持有更好的路由信息的情况下。路由器会通过这样的 ICMP 消息告知发送端，让它下次发给另外一个路由器。

```
超时消息（ICMP Time Exceeded Message） —— 类型 11
```

IP 包中有一个字段叫做 TTL （Time To Live，生存周期），它的值随着每经过一次路由器就会减 1，直到减到 0 时该 IP 包会被丢弃。

此时，路由器将会发送一个 ICMP 超时消息给发送端主机，并通知该包已被丢弃。

（1）设置 IP 包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免 IP 包无休止地在网络上被转发。

（2）此外，有时可以用 TTL 控制包的到达范围，例如设置一个**较小的 TTL 值**。

![image-20220602192734161](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220602192734161.png)

### 2、ping —— 查询报文类型的使用

ping的发送与接收过程（同个子网下的主机 A 和 主机 B，主机 A 执行`ping` 主机 B 后）：

![image-20220602193335150](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220602193335150.png)

（1）ping 命令执行的时候，源主机首先会构建一个 **ICMP 回送请求**消息数据包。

​		ICMP 数据包内包含多个字段，最重要的是两个：

1. 第一个是类型，对于回送请求消息而言该字段为 8；

2. 另外一个是序号，主要用于区分连续 ping 的时候发出的多个数据包

   每发出一个请求数据包，序号会自动加 1。为了能够计算往返时间 RTT，它会在报文的数据部分插入发送时间。

![image-20220602193534461](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220602193534461.png)

（2）然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为**目的地址**，本机 IP 地址作为**源地址**，**协议**字段设置为 `1` 表示是 `ICMP` 协议，再加上一些其他控制信息，构建一个 `IP` 数据包。![image-20220602193604035](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220602193604035.png)

（3）接下来，需要加入 MAC 头。如果在本地 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 ARP 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。
![image-20220602193622172](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220602193622172.png)

（4）主机 B 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。

接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。

主机 B 会构建一个 **ICMP 回送响应**消息数据包，回送响应数据包的类型字段为 0，序号为接收到的请求数据包中的序号，然后再发送出去给主机 A。
![image-20220602193648459](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220602193648459.png)

在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。

此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。

![image-20220602193719333](C:\Users\35144\AppData\Roaming\Typora\typora-user-images\image-20220602193719333.png)

当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。

但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据目标 IP 地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址。

说了这么多，可以看出 ping 这个程序是使用了 ICMP 里面的 ECHO REQUEST（类型为 8 ） 和 ECHO REPLY （类型为 0）。

### 3、traceroute —— 差错报文类型的使用

有一款充分利用 ICMP **差错报文类型**的应用叫做 `traceroute`（在UNIX、MacOS中是这个命令，而在Windows中对等的命令叫做 tracert ）。

#### （1）作用一

traceroute 的第一个作用就是**故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器。**

traceroute 的参数指向某个**目的 IP 地址**，例如

```
traceroute 192.168.1.100
```

作用原理：

它的原理就是利用 IP 包的生存期限 从 1 开始按照顺序递增的同时发送 UDP 包，强制接收 ICMP 超时消息的一种方法。

比如，将 TTL 设置 为 1，则遇到第一个路由器，就牺牲了，接着返回 ICMP 差错报文网络包，类型是时间超时。

接下来将 TTL 设置为 2，第一个路由器过了，遇到第二个路由器也牺牲了，也同时返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。

这样的过程，traceroute 就可以拿到所有的路由器 IP。

当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。


发送方如何知道发出的 UDP 包是否到达了目的主机呢？

traceroute 在发送 UDP 包时，会填入一个不可能的端口号值作为 UDP 目标端口号（大于 3000 ）。当目的主机收到 UDP 包后，会返回 ICMP 差错报文消息，但这个差错报文消息的类型是「端口不可达」。

所以，当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。

#### （2）作用二

**故意设置不分片，从而确定路径的 MTU**。

```
最大传输单元（Maximum Transmission Unit，MTU）用来通知对方所能接受的数据服务单元的最大尺寸，说明发送方能够接受的有效载荷大小。 
是包或帧的最大长度，一般以[字节]记。如果MTU过大，在碰到路由器时会被拒绝转发，因为它不能处理过大的包。如果太小，因为协议一定要在包(或帧)上加上包头，那实际传送的数据量就会过小，这样也划不来。大部分操作系统会提供给用户一个默认值，该值一般对用户是比较合适的。
```

这样做的目的是为了**路径MTU发现**。

因为有的时候我们并不知道路由器的 `MTU` 大小，以太网的数据链路上的 `MTU` 通常是 `1500` 字节，但是非以外网的 `MTU` 值就不一样了，所以我们要知道 `MTU` 的大小，从而控制发送的包大小。

![MTU 路径发现（UDP的情况下）](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QvJUU4JUFFJUExJUU3JUFFJTk3JUU2JTlDJUJBJUU3JUJEJTkxJUU3JUJCJTlDL3BpbmcvMTguanBn?x-oss-process=image/format,png)

它的工作原理如下：

首先在发送端主机发送 IP 数据报时，将 IP 包首部的分片禁止标志位设置为 1。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。

随后，通过一个 ICMP 的不可达消息将数据链路上 MTU 的值一起给发送主机，不可达消息的类型为「需要进行分片但设置了不分片位」。

发送主机端每次收到 ICMP 差错报文时就减少包的大小，以此来定位一个合适的 MTU 值，以便能到达目标主机。












# 4. OS

进程与线程的区别  深入Linux内核讲copy_process()

线程切换是在什么情况下，如何实现

线程间通信 

线程会共享内存吗

线程池的状态，设计思路

协程及其如何实现，如何切换；协程执行的时机

五种IO模型，同步阻塞

多路复用

内存分配的策略（小贺操作系统T49-50）

中断与异常

Linux内核的fork实现

Linux设置后台进程

僵尸进程与孤儿进程

虚拟内存概念

程序员在写程序时需要考虑虚拟内存吗？

阿秀操作系统54 原子操作的是如何实现的


服务器端口未打开怎么通知客户端，客户端在哪一阶段发现服务器端口未打开



IO多路复用 -> 从同步阻塞到IO多路复用的必要性      小林os9.2

epoll源码  epoll优势   epoll中LT和ET模式，概念以及详细的优劣势   小林os9.2



惊群效应及其避免（等待队列只唤醒一个，但是这是内核后来的做法）

早期内核如何处理惊群效应。如果用锁的话该怎么实现呢——如果监听的事件是在文件上，那么就可以获取文件描述符上的锁，每个进程操作前应该检查其锁标记。

锁相关问题 互斥量/条件变量/自旋锁/读写锁/信号量  [c++](https://www.nowcoder.com/jump/super-jump/word?word=c%2B%2B)11的线程/锁；自旋锁与互斥锁的区别

操作系统的文件管理

32位机的寻址空间

在实际情况中文件相互引用也会造成死锁 -> 讲了链接时候的头文件引用情况

物理地址和逻辑地址之间的转换 -> 从Linux的内存管理到MMU

简介网络层模型 -> 知道Linux内协议栈的实现吗

数据在内核空间和用户空间之间的拷贝 -> 零拷贝问题（讲到CSAPP中浅显的DMA）



# 5. 数据库

关系型数据库MySQL和内存型数据库Redis、Memcached

InnoDB引擎

索引失效的场景

[redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)底层的数据结构

[redis](https://www.nowcoder.com/jump/super-jump/word?word=redis)的哈希与渐进式哈希

skiplist和 [红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)性能分析

nginx负载均衡

levelDB

最左前缀原则  MySQL有哪些索引相关的规则 -> 只知道联合索引中最左前缀原则

多个任务直接有依赖关系，通过什么数据结构描述这个关系

redis

​		详细讲一讲持久化中的AOF与RDB以及各自优劣势

​		Redis采用的是什么方式呢 -> 说了两者结合->具体是如何两者结合的呢

​		跳表和[红黑树](https://www.nowcoder.com/jump/super-jump/word?word=红黑树)的比较

​		Redis缓存和数据库的一致性，延迟双删

写一个MySQL语句 -> 类似 牛客185. 部门工资前三高的所有员工

为什么选择B+树作为索引，回表是什么

索引下推

消息队列如何保证不丢消息

为什么选用Redis做消息队列 -> 简单易部署，并发要求低   [面试题：用Redis实现一个消息队列](https://www.jianshu.com/p/f64567b7b66f)

RabbitMQ和kafka









# 6. ELSE

共享内存的实现

压测工具（webbench的使用和原理）

工厂模式

单例模式

渲染管线

防止重复提交多个请求的方法

如何防止对网页的爬取（比如小说网的小说）

linux查看进程状态

linux查看进程打开的文件

一个程序能产生随机数，利用一个接口读取随机数中第K大的数，怎么实现？如果数据很多怎么实现？

怎么查看cpu占用率？

makefile /shell脚本

git  一个分支同步另一个分支的一个commit  什么命令

linux命令 把服务器的一个文件拷贝到本地

帧同步与状态同步

描述调用main函数、实例化类，调用类中的成员函数，这一系列操作中程序的执行过程。

大型文件编译的方法 -> 说了make，CMakeLists，scons

看一下muduo库：muduo库中你觉得最巧妙的设计

