# 随机数

## 1. 引入

C++可以通过两个步骤生成随机数，即"虚拟骰子"。两个步骤：

- 设置随机数种子。
- 通过复杂的数学运算生成序列中的下一个数（细节不重要）。

但是有一个问题：

虽然序列几乎不可能预测，但它仍是确定性的，数字计算机中的一切都是确定性的。不设置随机数种子，程序每次运行都获得相同的随机数序列。所以，第二次生成的数就不是真正的随机数了（即伪随机）。为防止这种情况的发生，必须设置种子，而且每次都要不同。这就回到了原来的问题：从哪里获得这样的一个数？解决方案很简单：**系统时间**。

## 2. C++中的做法

引入两个库

```C++
# include <cstdlib> // 支持srand和rand函数
# include <ctime> //支持ctime函数
```

包含cstdlib后，就获得了随机函数的声明。包含ctime是因为要用到时间函数。
下一步是设置种子。记住**不管程序要获得随机数多少次，都只需设置该种子值一次**：

```C++
srand (time (nullptr));
```

> 注意：
>
> 从C++11 开始支持nullptr关键字，即 空指针（null pointer）。如编译器较老，可改为NULL或0。

设置号随机数种子后，就可调用rand函数来生成随机数了。再次提醒，种子值无需多次设置。

```cpp
cout << rand () << endl; //打印一个随机数
cout << rand () << endl; // 打印另一个
```

下面是模拟10次掷骰子每次生成1-6的随机数

```C++
int main () {
    srand (time(nullptr));
    for (int i = 0; i < 10; ++i) cout << (rand() % 6) + 1 << endl;
    return 0;
}
```

## 3. 优化

如果使用Microsoft Visual Studio，你可能会注意到调用`srand()`会造成开发环境显示一条警告。因为将`time_t`类型（一个长整数）的数据赋给获取`unsigned int `的函数后，可能造成数据丢失。
两个都是整数，正负号也不是问题，所以可安全忽略该警告。但许多老程序员不喜欢警告。解决方案是执行强制类型转换（cast）。最简单的是老式C风格的强制类型转换。

```C
srand ((unsigned int) time (nullptr));
```

然而，目前的首选方案是使用新的强制类型转换操作符static_cast。语法有点复杂，也不好看，但成为首选是有原因的。

```C++
srand (static_cast <unsigned int> (time(nullptr)));
```

static_cast常规语法如下所示：

```C++
static_cast <类型>(表达式)
```

它获取指定表达式，并将其转换成指定类型。即使编译器已知如何转换（比如将有符号整型赋给无符号整型），不显示执行强制类型转换还是消除不了警告。