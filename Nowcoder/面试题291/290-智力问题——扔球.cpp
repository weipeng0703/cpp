// 题目
/*
给你两个球，100层楼，每个球在一定高度扔下去会碎，怎么用最少的次数判断是几层楼能把球摔碎？

*/

// 解答
/*
首先，为了保存下一颗玻璃珠自己玩，就采用最笨的办法吧：从第一层开始试，每次增加一层，当哪一层扔下玻璃珠后碎掉了，也就知道了。不过最坏的情况扔的次数可能为100。
当然，为了这一颗玻璃珠代价也高了点，还是采取另外一种办法吧。随便挑一层，假如为N层，扔下去后，如果碎了，那就只能从第一层开始试了，最坏的情况可能为N。假如没碎，就一次增加一层继续扔吧，这时最坏的情况为100-N。也就是说，采用这种办法，最坏的情况为max{N, 100-N+1}。之所以要加一，是因为第一次是从第N层开始扔。
不过还是觉得不够好，运气好的话，挑到的N可能刚好是临界楼层，运气不好的话，要扔的次数还是很多。不过回过头看看第二种方式，有没有什么发现。假如没摔的话，不如不要一次增加一层继续扔吧，而是采取另外一种方式：把问题转换为100-N，在这里面找临界楼层，这样不就把问题转换成用递归的方式来解决吗？看下面：
假如结果都保存在F[101]这个数组里面，那么：
F[N]=100-N，
F[100]=min（max（1，1+F[N-1]），max（2，1+F[N-2]），……，max（N-1，1+F[1]））;
看出来了没有，其实最终就是利用动态规划来解决这个问题。

编码如下

证明方法
1、第一次抛棋子的楼层：最优的选择必然是间隔最大的楼层。比如，第一次如果在m层抛下棋子，以后再抛棋子时两次楼层的间隔必然不大于m层（大家可以自己用反证法简单证明） 
2、从第二次抛棋子的间隔楼层最优的选择必然比第一次间隔少一层，第三次的楼层间隔比第二次间隔少一层，如此，以后每次抛棋子楼层间隔比上一次间隔少一层。（大家不妨自己证明一下） 
3、所以，设n是第一次抛棋子的最佳楼层，则n即为满足下列不等式的最小自然数： 
  不等式如下：   1+2+3+...+(n-1)+n   >=   100 
由上式可得出n=14 
即最优的策略是先从第14层抛下，最多抛14次肯定能找出临界楼层

*/

#include<iostream>
using namespace std;

int F[101] = {0};

void Test()
{
    int temp;
    for (int loop1 = 2; loop1 < 101; ++loop1)
    {
        F[loop1] = loop1;
        for (int loop2 = 1; loop2 < 101; ++loop2)
        {
            temp = (loop2 >= (1 + F[loop1 - loop2])) ? loop2 : (1 + F[loop1 - loop2]);
            if (F[loop1] > temp)
                F[loop1] = temp;
        }
    }
}

int main()
{
     F[0] = 0;
     F[1] = 1;
     Test();
     cout << F[100] << endl;
     return 0;
}

// 输出结果为14。也就是说，最好的方式只要试14次就能够得出结果了。
 
// 答案是先从14楼开始抛第一次；如果没碎，再从27楼抛第二次；
// 如果还没碎，再从39楼抛第三次；
// 如果还没碎，再从50楼抛第四次；如此，每次间隔的楼层少一层。
// 这样，任何一次球碎时，都能确保最多抛14次可以找出临界楼层。
