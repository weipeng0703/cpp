// 写一个“标准”宏MIN，这个宏输入两个参数并返回较小的一个。另外，当你写下面的代码时会发生什么事？  
// least = MIN(*p++, b);  

// 解答
/*
#define MIN(A, B) ((A) < (B)) ? (A) : (B) 

least会产生副作用
*/

// 知识点
/*
考查对宏定义的使用，宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，
在宏展开的时候对“参数”进行的是一对一的替换。

程序员对宏定义的使用要非常小心，特别要注意两个问题：  

（1）谨慎地将宏定义中的“参数”和整个宏用用括弧括起来。所以，严格地讲，下述解答：  
#define MIN(A,B) (A) <= (B) ? (A) : (B)
#define MIN(A,B) (A <= B ? A : B )
都应判0分；  
（2）防止宏的副作用。  
宏定义#define MIN(A,B) ((A) <= (B) ? (A) : (B))对MIN(*p++, b)的作用结果是：  
((*p++) <= (b) ? (*p++) : (b))   
这个表达式会产生副作用，指针p会作2次++自增操作。  

除此之外，另一个应该判0分的解答是：  
#define MIN(A,B) ((A) <= (B) ? (A) : (B)); 
这个解答在宏定义的后面加“;”  


*/
